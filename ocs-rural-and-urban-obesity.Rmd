---
title: "ocs-rural-and-urban-obesity"
css: style.css
output:
  html_document:
    code_download: yes
    highlight: tango
    number_sections: no
    theme: cosmo
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
  word_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(include = TRUE, comment = NA, echo = TRUE,
                      message = FALSE, warning = FALSE)
```


## Background
BMI is measured as an individual's weight in kilograms divided by the individual's height in meters squared. Different categories of weight are defined with the following cutoffs:

![](https://cdn.vertex42.com/ExcelTemplates/Images/bmi-chart.gif)

An [article](https://www.nature.com/articles/s41586-019-1171-x.pdf) published in Nature evaluated and compared the Body-Mass Index (BMI) of populations in rural and urban communities around the world: 

```{r, echo = FALSE, out.width="100%", message=FALSE}
library(here)
knitr::include_graphics(here::here("paper.png"))

```

#### {.particular_topic_block}
NCD Risk Factor Collaboration (NCD-RisC). Rising rural body-mass index is the main driver of the global obesity epidemic in adults. *Nature* 569, 260–264 (2019). 

####
This article challenged the widely-held view that increased urbanization was one of the major reasons for increased global obesity rates. This view came about because many countries around the world have shown increased urbanization levels in parallel with increased obesity rates. However this study demonstrated that this might not be the case. This case study will evaluate the data reported in this article to explore regional and gender specific differences in the obesity rates around the world in 1985 and 2017. Most importantly we will test if there is a difference in obesity rates between rural and urban communities.

<u>Note:</u> While sex is not actually binary, the data presented that is used in this analysis contains data only for groups of individuals described as male or female.

The measurement of BMI has some [limitations](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4890841/pdf/nt-50-117.pdf) that are well recognized, as it does not account for the composition of body mass, the location of body fat, or the contribution of body frame size. However, [BMI has been a useful health indicator](https://journals.lww.com/acsm-healthfitness/Fulltext/2016/07000/THE_BENEFITS_OF_BODY_MASS_INDEX_AND_WAIST.8.aspx#pdf-link) for risk for many diseases particularly when combined with other risk factor information.


## Data Import

First let's download the data:
```{r}
library(here)
library(XML)

url <- "https://static-content.springer.com/esm/art%3A10.1038%2Fs41586-019-1171-x/MediaObjects/41586_2019_1171_MOESM1_ESM.pdf"

download.file(url, "paper_supplement.pdf")
```

Now that we have the obesity pdf, we will read it in to R using the  pdftools package:

```{r}
library(pdftools)

pdf_obesity<-pdf_text(here("paper_supplement.pdf"))# PDF error: Expected the optional content group list, but wasn't able to find it, or it isn't an Array - errors like this can be common with PDFs... we can take a look at the data to see if it still looks as expected
```

Let's take a look at the data- the summary() function helps us to look at the structure of R objects.

```{r}
summary(pdf_obesity)
```

We can see that we have 63 elements that are character strings. You may also notice that the original PDF has 63 pages. Let's take a look at some of these elements.

```{r}
pdf_obesity[1] # this looks like the first page
pdf_obesity[2] # this looks like the second page
```

```{r, eval = FALSE}
pdf_obesity[55] # this looks like data in a the table we are interested in
```

```{r, echo = FALSE, out.width="100%", message=FALSE}
library(here)
knitr::include_graphics(here::here("page55.png"))

```


We can see that the output looks pretty similar to the pages of the pdf, but the spacing is quite awkward. The way the data is displayed is partially influenced by how width setting of the RStudio window.  

We are interested in a supplementary Table 3. which has multiple pages and includes the same header on each page; we can use that to determine what elements of our pdf_obesity character strings include our table. We will use the str_detect() function of the stringr package to search for the elements that contain text that is consistently in the header. The output of of this function will show which elements of the object (in this case pages of the pdf) include this pattern indicated as a "TRUE" or "FALSE".

```{r}
library(stringr)
str_detect(pattern = "Age-standardised mean BMI", string = pdf_obesity)# "Age-standardised mean BMI" is part of the header in the table on every page in the pdf. This shows the pages that contain our table of interest (as TRUE values).
```

Let's extract just the data for the table now and call it rural_urban.
```{r}
rural_urban <-pdf_obesity[str_detect(pattern ="Age-standardised mean BMI", string =pdf_obesity)]

str(rural_urban) # the str() function (which is similar to the summary function) shows us that there are 10 pages worth of elements in our rural_urban object

```


Let's check the first and last page:

```{r, eval=FALSE}
cat(rural_urban[1]) # using the cat() function which stands for Concatenate And Print will allow for the "\n" values to be shown as spaces
```


```{r, echo = FALSE}
knitr::include_graphics(here::here("first_page_in_R.png"))
```


```{r, echo = FALSE}
knitr::include_graphics(here::here("first_page.png"))
```

This looks the same as the beginning... how about the end?

```{r, eval =FALSE}
cat(rural_urban[10])
```


```{r, echo = FALSE}
knitr::include_graphics(here::here("last_page_in_R.png"))
```


```{r, echo = FALSE }
knitr::include_graphics(here::here("last_page.png"))
```


Great! Our rural_urban object looks like it contains the entire Supplementary 3 table, as both the beginning and the end include the data we expected.

## Wrangling

At this point we have large strings now for each page of the table, but this is not very convenient to work with. Now we will wrangle the data into a more usable form. Ideally we would like our data to be in some sort of tabular form.

First it would be useful to separate each page into lines.
```{r}
library(readr)
rural_urban <-read_lines(rural_urban)
str(rural_urban) # now we have 461 lines
rural_urban[6] # we can see that line 6 shows the data for females in Afghanistan  
```

We also have a lot of white-space... let's get rid of the excess white spaces using `str_squish()`.

```{r}
library(tidyverse)
rural_urban<-str_squish(rural_urban) 
head(rural_urban)
```

Now it is much easier to see the data.

If we look at the end of the first page of the table and the start of the second we can see that the header information is repeated, as well as a line with the page number and an empty line, and a line that says "2 2".
```{r}
rural_urban[44:56]
```

Although the header was necessary on all of the pages of the pdf version of the table, we only need that information once in our data.


So, let's remove all the header information and the page number lines from the rural_urban object, then we will make a single line header for the beginning.
One way to do this is to find all lines that include either "women" or "men" and only keep this data.
```{r}
str_which(string = rural_urban, pattern = "Women|Men") # Here the "|" indicates that we are looking for either the "Women" or "Men" patterns
```

OK, so this looks correct. This includes most lines but there are gaps where are header is located.

```{r}
rural_urban <- rural_urban[str_which(string = rural_urban, pattern = "Women|Men")]
```

We can check our data now using either head() or glimpse().
```{r}
library(dplyr)
glimpse(rural_urban)
```

```{r}
head(rural_urban)
```

So the `head()` function shows us the first rows or lines of the data, while the `glimpse()` function provides us information about the total size of the object and shows us the first line or row.

Great! So now our data looks much better but we need to add back our header and we would like this to only be a single line to make it easy to transform our data into a table or table-like object.

```{r, echo = FALSE}
knitr::include_graphics(here::here("last_page.png"))
```


First let's try splitting our header-less data into columns based on spaces:
```{r}
(str_split(rural_urban, " ", simplify = TRUE))[1:10,] # here we will take a look at just the first 10 lines
```

This almost worked, but unfortunately country names that have spaces will be a problem. We can see that American Samoa has been divided into two columns and all subsequent columns are shifted.


So now let's try to extract the country information, by separating the country information from the sex information when the sex is female. Sex always starts with either a capital "W" if the gender is female. We need to use a space before the "W" otherwise we will split some of the country names if the names starts with "W". Here we will also introduce the concept of piping, which uses the `%>%`. This is really useful when we have multiple steps, which we will show soon.
```{r}

Women <- stringr::str_subset(string = rural_urban, pattern = "Women") # First let's subset the data to only the lines that contain "Women"

country_split <-Women %>%
  stringr::str_split(pattern= " W") %>%
  unlist() 


head(country_split)
```

Now we can see that Country is always the odd rows and the rest of the data is the rest of the rows

```{r}
country <-data.frame(country_split) %>% 
  dplyr::filter(row_number() %% 2 == 1) 
country
Women_BMI <-data.frame(country_split) %>% 
  dplyr::filter(row_number() %% 2 == 0)
```


Great! Now we have a list of the countries that can be used for both the male and female data. 

Let's add the "W" back to our Women data:
```{r}
glimpse(Women)
Women<-Women_BMI %>%
mutate(country_split =stringr::str_replace_all(string =country_split, pattern ="omen", replacement = "Women"))
head(Women$country_split)
```

It's always a good idea to check that your data objects are the size you expect when wrangling.

```{r}
dim(Women)
```
Great! There are 200 rows like we expected.

Let's grab the male data:

```{r}
# remember our rural_urban object contains male data for the odd rows

Men <-data.frame(rural_urban) %>% 
  dplyr::filter(row_number() %% 2 == 1) 
head(Men$rural_urban)
dim(Men) # again let's make sure we have the correct number of rows for our final "Men" data object
```
How about our number of columns? 

If we try splitting our data by space again, will it have the expected number of columns? What about the rows that contain na* values?
```{r}
unknown <-Men %>%filter(str_detect(pattern ="na\\*", string = rural_urban)) # let's just take the Men data that contains na* values - this column is called rural_urban
as_tibble(str_split(unknown$rural_urban, " ", simplify = TRUE)) # now we can try splitting by a space

```

So close! Notice that the `na*` values  have shifted the subsequent values within the columns because typically there is a space between the BMI and the credible intervals. Here we can see this data in our original pdf:

```{r, echo = FALSE, out.width="100%"}
knitr::include_graphics(here::here("missing_pdf.png"))
```

We need to replace our `na*` values  with something that includes a space so that when we separate our data by space we will have two values instead of one when we have an `na*`. Therefore, `na* na*` should work.

```{r}
class(Men$rural_urban)# In order to use the functions within the stringr package, our Men data needs to be of character class
Men<-as.character(Men$rural_urban) # This function allows us to change the factor data within Men$rural_urban to the character class and we are changing the structure so that the data is directly just called Men and not within a vector called rural_urban
Men<-stringr::str_replace_all(string = Men, pattern = "na\\*", replacement = "na\\* na\\*") # the \\ are necessary because the * is a special character that would typically indicate that any possible value, but here we actually want a `*` instead, thus the double backslash does that for us.
# Here we are replacing all occurences of the na* values (thus str_replace_all instead of str_replace) that occur in the strings within Men with na* na*. 
#To check that this worked...
Men[20:30]
#YAY!


# Now for the Women data object
class(Women$country_split)# the female data is already in character form
Women<-stringr::str_replace_all(string = Women$country_split, pattern = "na\\*", replacement = "na\\* na\\*") 
Women[20:30]

```


Great, now we can split our data by spaces.



```{r}
Men <-as_tibble(str_split(Men, " ", simplify = TRUE))# note here we need to use the column of Women that has the data
head(Men)
Women<-as_tibble(str_split(Women, " ", simplify = TRUE))# note here we need to use the column of Women that has the data
head(Women)
Women[20:30,] # we can see that our na values look correct
```

We can see from our pdf and our object called header what the header was like. Let's also make a new single line header, but let's wait to add Country:

```{r}
#header
new_header <-c("Sex","National_BMI_1985", "National_BMI_1985_CI", "Rural_BMI_1985", "Rural_BMI_1985_CI", "Urban_BMI_1985", "Urban_BMI_1985_CI", "National_BMI_2017", "National_BMI_2017_CI","Rural_BMI_2017", "Rural_BMI_2017_CI", "Urban_BMI_2017", "Urban_BMI_2017_CI")
```


Let's change the names of our columns of our tibble to this new header for our Men and Women data

```{r}
names(Women)<-new_header
names(Men)<-new_header
```


Now we will add our country data to both our Men and Women tibbles 

```{r}
Women <- dplyr::bind_cols(country, Women)# this will add the country as a new column to the Women data object on the left 
Men <- dplyr::bind_cols(country, Men) # this will add the country as a new column to the Men data object on the left 
head(Women)
```

Here we will change the variable name of the country data to country, currently it is called country_split. Here we will also introduce the concept of the assignment pipe. In this case our pipe operator looks like this `%<>%` .  Using this fancier pipe requires another package,  called magrittr. The other simpler pipe options from this package are loaded with tidyverse, but not this fancier version. 

The `>` portion of the pipe still behaves like a normal pipe, while the `<` portion of the pipe makes an assignment to whatever the `<`is pointing to, just like when we use the typical assignment operator `<-`. 

```{r}
library(magrittr)
# Here we will just use the traditional assignment strategy
Women<-rename(Women, Country = country_split) # here we will rename the country_split variable to be called country

# Here we reassign Men using the pipe strategy
Men %<>%rename(Country = country_split) # here we will rename the country_split variable to to be called country and then reassign Men to the data object which has the country variable renamed
```

Now we can combine our Men and Women data. This will put all the female data first (x) and all the male data second (y).

```{r}
BMI<-dplyr::full_join(x = Men, y = Women)
str(BMI)#let's check the size of our BMI data... it should have 400 rows (obs).

```

Now Lets sort the data by country:

```{r}
BMI <-dplyr::arrange(BMI, Country)
head(BMI)

```

Our data is looking great! Now we might want to make sure that our observations for each variable look the way we want. In other words if we want to make plots about National BMI in 1985 then we would need our values to be numeric. Looking at our BMI data using `str()`, we can see the type of data for each of our variables listed just after variable name and the `:`. Looks like none of our BMI data is actually numeric. Let's change that now.

```{r, warning=FALSE}
str(BMI)
BMI$National_BMI_1985%<>% as.numeric
BMI$Rural_BMI_1985%<>% as.numeric
BMI$Urban_BMI_1985%<>% as.numeric

BMI$National_BMI_2017%<>% as.numeric
BMI$Rural_BMI_2017%<>% as.numeric
BMI$Urban_BMI_2017%<>% as.numeric

str(BMI)# we can see now these variables show as "num" which stands for numeric

#We might want to just compare males and females or look at their data separately... since we already have this data let's also make these values numeric for these data objects
Women$National_BMI_1985%<>% as.numeric
Women$Rural_BMI_1985%<>% as.numeric
Women$Urban_BMI_1985%<>% as.numeric

Women$National_BMI_2017%<>% as.numeric
Women$Rural_BMI_2017%<>% as.numeric
Women$Urban_BMI_2017%<>% as.numeric

Men$National_BMI_1985%<>% as.numeric
Men$Rural_BMI_1985%<>% as.numeric
Men$Urban_BMI_1985%<>% as.numeric

Men$National_BMI_2017%<>% as.numeric
Men$Rural_BMI_2017%<>% as.numeric
Men$Urban_BMI_2017%<>% as.numeric

```


## Data Exploration

Now that our data is clean and in a format that we can work with, we can start to take a look at the data and how different groups might compare.

One of the first things that is useful to do with data is to plot the frequency of the different possible values. This is called a `distribution`. To do this we can use the `hist()` function to create a histogram.

If the data were what we call `normally distributed` then the distribution should be equally centered around the mean and would look something like this:

```{r}
norm_BMI_ex_data <- rnorm(n = 200, mean = 24) # this function allows us to make a vector of normaly distributed data centered around the mean of 24
hist(norm_BMI_ex_data)
```

Alternatively we can plot this using the `qplot()` function of the `ggplot2 package`:

```{r}
qplot(norm_BMI_ex_data)
qplot(norm_BMI_ex_data, bins = 15) # we can modify how we bin our histogram using the bin argument- in other words, how many bars would we like to include
```

Let's see how our data looks:
```{r}
qplot(BMI$National_BMI_1985, bins = 15)
```

OK, so the data looks like it is what we call `right skewed` because the tail of the distribution is longer on the right side.

What does the rest of our data look like? We could check by doing something like this, but this is a lot of code:
```{r, eval = FALSE}

qplot(BMI$Rural_BMI_1985, bins = 15)
qplot(BMI$Urban_BMI_1985, bins = 15)

qplot(BMI$National_BMI_2017, bins = 15)
qplot(BMI$Rural_BMI_2017, bins = 15)
qplot(BMI$Urban_BMI_2017, bins = 15)

qplot(Women$National_BMI_1985, bins = 15)
qplot(Women$Rural_BMI_1985, bins = 15)
qplot(Women$Urban_BMI_1985, bins = 15)

qplot(Women$National_BMI_2017, bins = 15)
qplot(Women$Rural_BMI_2017, bins = 15)
qplot(Women$Urban_BMI_2017, bins = 15)

qplot(Men$National_BMI_1985, bins = 15)
qplot(Men$Rural_BMI_1985, bins = 15)
qplot(Men$Urban_BMI_1985, bins = 15)

qplot(Men$National_BMI_2017, bins = 15)
qplot(Men$Rural_BMI_2017, bins = 15)
qplot(Men$Urban_BMI_2017, bins = 15)
```
 
 Alternatively if we want to plot all of these we can do something like this:
 
```{r, warnings = FALSE}

data_hist <-BMI %>% select(-matches("CI|ex|Country"))# to remove columns with names containing CI, such as "Urban_BMI_1985_CI or "Country" or "Sex" - I could not recall if Sex was capitalized so using "ex" allowed me to remove that column regardless
rownames(data_hist)<- paste(BMI$Country, BMI$Sex, sep = "_") # to keep track of the data we can rename the rownmanes of the newly created data with the Country and the Sex data
make_hist <- function(x) {qplot(x, bins = 15)}
lapply(data_hist, make_hist) # this allows his to apply the hist() function to all the columns in data_hist
```

Doing the same with the Men and Women data, we can combine our histograms into one plot for each using the gridExtra package:
 
```{r, warnings = FALSE}
library(gridExtra)
data_hist_Men <-Men %>% select(-matches("CI|ex|Country"))
rownames(data_hist_Men)<- paste(Men$Country, Men$Sex, sep = "_")
Men_hist<-lapply(data_hist_Men, make_hist)
do.call(grid.arrange, Men_hist)

data_hist_Women <-Women %>% select(-matches("CI|ex|Country"))
rownames(data_hist_Women)<- paste(Women$Country, Women$Sex, sep = "_")
Women_hist<-lapply(data_hist_Women, make_hist)
do.call(grid.arrange, Men_hist)

```

In general the data for the Men looks less normal but it is a bit harder to tell for some of the data for the Women.

Let's use a method called quantile quantile plotting to determine if the data is indeed normally distributed. These plots are called `QQ plots`. This method allows us to test the fit of known theoretical distributions (like the normal distribution) with our observed distribution. To do this we will plot the quantiles of our data on the y-axis and the quantiles of the theoretical normal distribution on the x-axis. If the quantiles line up then we can say that our data is fairly normal. What exactly is a `quantile`? This is a division of the data distribution into roughly equal portions.

Here is an example of a QQ plot for the normally distributed data that we just created:

```{r}

qqnorm(norm_BMI_ex_data)
qqline(norm_BMI_ex_data)

```

Here we can see that the quantiles are fairly similar bewteen the observed and theoretical data. We see that the points mostly fall on the line, however there are some points that are a bit further from the line as we get to the extreme quantiles. Notice that the sample quantiles (which will be fairly similar to our real BMI data quantiles) on the y-axis has the same range as the values that we created. So values that are bellow 22 for example are represented as the points bellow 22 on the y-axis. As expected we see that about half the points are bellow our mean of 24.

If we were to use different data that had a range of differnt values our y-axis would shift according to the range of values. For example the Orange data within the installation of R includes data about the circumfrance of orange trees in millimeters. Here we can see that the quantiles are quite different but reflect the range of orange tree circumfrances.
```{r}
range(Orange$circumference)
qqnorm(Orange$circumference)
qqline(Orange$circumference)
```


Let's take a look at our BMI data:

```{r}


qqnorm(BMI$National_BMI_1985, ylab = "1985_BMI_quantiles")
qqline(BMI$National_BMI_1985)

qqnorm(BMI$National_BMI_2017, ylab = "2017_BMI_quantiles")
qqline(BMI$National_BMI_2017)

qqnorm(Men$National_BMI_1985, ylab = "Men_1985_BMI_quantiles")
qqline(Men$National_BMI_1985)

qqnorm(Women$National_BMI_2017, ylab = "Women_1985_BMI_quantiles") # this looks pretty close
qqline(Women$National_BMI_2017)

```
We can see that at the extremes of our quantiles, for most of our data, our tails are not very similar to the theoretical distribution.

Finally, you can also use the Shapiro-Wilk test for normality when the qqplot is a bit unclear.

```{r}

shapiro.test(norm_BMI_ex_data) # example of the test output for normal data
shapiro.test(BMI$National_BMI_1985)
shapiro.test(BMI$National_BMI_2017)
shapiro.test(Women$National_BMI_1985)
shapiro.test(Men$National_BMI_1985)
shapiro.test(Men$Urban_BMI_1985)
shapiro.test(Men$Rural_BMI_1985)
shapiro.test(Women$Urban_BMI_1985)
shapiro.test(Women$Rural_BMI_1985)
shapiro.test(BMI$Urban_BMI_1985)
shapiro.test(BMI$Rural_BMI_1985)

shapiro.test(Men$National_BMI_2017)
shapiro.test(Men$Urban_BMI_2017)
shapiro.test(Men$Rural_BMI_2017)
shapiro.test(Women$Urban_BMI_2017)
shapiro.test(Women$Rural_BMI_2017)
shapiro.test(BMI$Urban_BMI_2017)
shapiro.test(BMI$Rural_BMI_2017)
# in all of these cases our data does not appear to be normally distributed
```
We are interested in comparing male and female BMI measurements, as well as rural and urban, but the data does not appear to be normally distributed. Often when comparing two groups we might perform a two sample t test to determine if the means of each group is different. The two sample t test however, relies on several assumptions:

1) The data for both groups is normally distributed
2) The variance of both groups is similar

If these assumptions are violated, this doesn't necessarily mean we can't perform a t test. It just means we may have to transform the data to make it normally distributed and we may need to peform the t test in a special way to account for the difference in the variance in the two groups. Alternatively, we can use a nonparametric test like the Wilcoxon–Mann–Whitney (WMW) test. We will explore both of these options.

Let's check if the variance of the rural and urban data is equal using the `var.test()` function.

```{r}
var.test(BMI$Rural_BMI_1985, BMI$Urban_BMI_1985)
var.test(BMI$Rural_BMI_2017, BMI$Urban_BMI_2017)
```

Our p value is less than .05 for both tests, thus we reject our null hypothesis that there is no difference in the variance. Therefore, we conclude that the variance is not equal and that our data also violates this assumption.

First let's see how the results look if we were to ignore the fact that our data does not appear to be normally distributed. We will perform a special t.test where we account for the fact that our variance is not equal.

```{r}
t.test(BMI$Rural_BMI_1985, BMI$Urban_BMI_1985, var.equal = FALSE)
t.test(BMI$Rural_BMI_2017, BMI$Urban_BMI_2017, var.equal = FALSE)

```


Now we will try transform our data to make it more normally distributed. One way to do this is to take the logarithm of the data values.

```{r}

BMI_log <-log(data_hist)
BMI_log_hist <-lapply(BMI_log, make_hist)
do.call(grid.arrange, BMI_log_hist)
lapply(BMI_log, shapiro.test)
```