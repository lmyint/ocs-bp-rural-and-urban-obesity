---
title: "Open Case Studies - Rural and Urban Obesity"
css: style.css
output:
  html_document:
    code_download: yes
    highlight: tango
    number_sections: no
    theme: cosmo
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
  word_document:
    toc: yes
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(include = TRUE, comment = NA, echo = TRUE,
                      message = FALSE, warning = FALSE)
```

```{r, echo = FALSE}
knitr::include_graphics(here::here("mainplot2.png"))
```

## Motivation
BMI is measured as an individual's weight in kilograms divided by the individual's height in meters squared. Different categories of weight are defined with the following cutoffs:

![](https://cdn.vertex42.com/ExcelTemplates/Images/bmi-chart.gif)

An [article](https://www.nature.com/articles/s41586-019-1171-x.pdf) published in Nature evaluated and compared the Body-Mass Index (BMI) of populations in rural and urban communities around the world: 

```{r, echo = FALSE, out.width="100%", message=FALSE}
library(here)
knitr::include_graphics(here::here("paper.png"))

```

#### {.particular_topic_block}
NCD Risk Factor Collaboration (NCD-RisC). Rising rural body-mass index is the main driver of the global obesity epidemic in adults. *Nature* 569, 260–264 (2019). 

####
This article challenged the widely-held view that increased urbanization was one of the major reasons for increased global obesity rates. This view came about because many countries around the world have shown increased urbanization levels in parallel with increased obesity rates. However this study demonstrated that this might not be the case. This case study will evaluate the data reported in this article to explore regional and gender specific differences in the obesity rates around the world in 1985 and 2017. Most importantly we will test if there is a difference in obesity rates between rural and urban communities. 

<b><u> Our main questions are: </u></b>

1) Is there a difference between rural and urban BMI estimates around the world?
2) How have BMI estimates changed from 1985 to 2017?
3) How do different countries compare for BMI estimates- in particular, how does the United States compare to the rest of the world?

In this case study, we’ll walk you through importing data from a pdf, cleaning data, wrangling data, visualizing the data, and comparing the means of two groups using well-established and commonly used packages, including stringr, tidyr, dplyr, purrr, and ggplot2. We will especially focus on using packages and functions from the [Tidyverse](https://www.tidyverse.org/). The Tidyverse is a library of packages created by the chief scientist at RStudio, Hadley Wickham. While some students may be familiar with previous R programming packages, these packages make data science in R especially efficient.

```{r, out.width = "20%", echo = FALSE, fig.align ="center"}
library(knitr)
include_graphics("https://tidyverse.tidyverse.org/logo.png")
```



We will begin by loading the packages that we will need:
```{r}
library(here)
library(pdftools)
library(stringr)
library(readr)
library(dplyr)
library(tibble)
library(magrittr)
library(purrr)
library(tidyr)
library(ggplot2)
library(data.table)
library(ggrepel)
library(cowplot)

```


 Package   | Use                                                                         
---------- |-------------
[here](https://github.com/jennybc/here_here)       | to easily load and save data
[pdftools](https://cran.r-project.org/web/packages/pdftools/pdftools.pdf)   | to read a pdf into R   
[stringr](https://stringr.tidyverse.org/articles/stringr.html)    | to manipulate the text within the pdf of the data 
[readr](https://readr.tidyverse.org/)      | to manipulate the text within the pdf of the data into individual lines  
[dplyr](https://dplyr.tidyverse.org/)      | to arrange/filter/select subsets of the data 
[tibble](https://tibble.tidyverse.org/)     | to create data objects that we can manipulate with dplyr/stringr/tidyr/purrr
[magrittr](https://magrittr.tidyverse.org/articles/magrittr.html)   | to use the `%<>%` pipping operator
[purrr](https://purrr.tidyverse.org/)      | to perform functions on all columns of a tibble
[tidyr](https://tidyr.tidyverse.org/)      | to convert data from wide to long format
[ggplot2](https://ggplot2.tidyverse.org/)    | to make visualizations with multiple layers
[data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html) | to create data objects that are similar to tibbles but different
[ggrepel](https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html)    | to allow labels in figures not to overlap
[cowplot](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html) | to allow plots to be combined
___


The first time we use a function, we will use the `::` to indicate what package we are using. Unless we have overlapping function names, this is not necessary, but we will include it here to illustrate what package we are using.


### Context

The measurement of BMI has some [limitations](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4890841/pdf/nt-50-117.pdf) that are well recognized, as it does not account for the composition of body mass, the location of body fat, or the contribution of body frame size. However, [BMI has been a useful health indicator](https://journals.lww.com/acsm-healthfitness/Fulltext/2016/07000/THE_BENEFITS_OF_BODY_MASS_INDEX_AND_WAIST.8.aspx#pdf-link) for risk for many diseases particularly when combined with other risk factor information.

## What are the Data?

We will be using data located within a table of the [supplementary material](https://static-content.springer.com/esm/art%3A10.1038%2Fs41586-019-1171-x/MediaObjects/41586_2019_1171_MOESM1_ESM.pdf) for the NCD-RisC paper referenced above. This is a pdf that can be found freely available online.


```{r, echo = FALSE}
knitr::include_graphics(here::here("first_page.png"))
```

Here you can see that the data contains mean BMI values for both Men and Women in various countries at the national level, as well as the mean BMI values for the rural and urban areas of these countries for both 1985 and 2017.

The data within the parentheses are the 95 % <b>credible interval</b> (CIs) ranges for the mean BMI estimates. The authors provide these CIs as a guide to understand how likely the estimate is for the true population mean BMI. A wider range suggests that the estimate is less accurate, as there are more possible values for the true mean with credible evidence.

<u>Note:</u> While [gender](https://www.genderspectrum.org/quick-links/understanding-gender/) and [sex](https://www.who.int/genomics/gender/en/index1.html) are not actually binary, the data presented that is used in this analysis only contains data for groups of individuals described as men or women. 

## Data Import

First let's download the data:
```{r}

url <- "https://static-content.springer.com/esm/art%3A10.1038%2Fs41586-019-1171-x/MediaObjects/41586_2019_1171_MOESM1_ESM.pdf"
utils::download.file(url, "paper_supplement.pdf")
```

Now that we have the obesity pdf, we will read it in to R using the `pdftools` package:

```{r}
pdf_obesity<-pdftools::pdf_text(here("paper_supplement.pdf"))
# PDF error: Expected the optional content group list, but wasn't able to find it, or it isn't an Array
# errors like this can be common with PDFs... we can take a look at the data to see if it still looks as expected
```

Let's take a look at the data- the `summary()` function helps us to look at the structure of R objects.

```{r}
summary(pdf_obesity)
```

We can see that we have 63 elements that are character strings. You may also notice that the original PDF has 63 pages. Let's take a look at some of these elements.

```{r}
pdf_obesity[1] # this looks like the first page
pdf_obesity[2] # this looks like the second page
```

```{r, eval = FALSE}
pdf_obesity[55] 
# this looks like data in a the table we are interested in
```

```{r, echo = FALSE, out.width="100%", message=FALSE}
library(here)
knitr::include_graphics(here::here("page55.png"))

```


We can see that the output looks pretty similar to the pages of the pdf, but the spacing is quite awkward. The way the data is displayed is partially influenced by how width setting of the RStudio window.  

We are interested in a supplementary Table 3. which has multiple pages and includes the same header on each page; we can use that to determine what elements of our pdf_obesity character strings include our table. We will use the `str_detect()` function of the `stringr` package to search for the elements that contain text that is consistently in the header. The output of of this function will show which elements of the object (in this case pages of the pdf) include this pattern indicated as a "TRUE" or "FALSE".

```{r}
stringr::str_detect(pattern = "Age-standardised mean BMI", string = pdf_obesity)
# "Age-standardised mean BMI" is part of the header in the table on every page in the pdf. 
# This shows the pages that contain our table of interest (as TRUE values).
```

Let's extract just the data for the table now and call it rural_urban.
```{r}
rural_urban <-pdf_obesity[stringr::str_detect(pattern ="Age-standardised mean BMI", string =pdf_obesity)]

str(rural_urban) 
# The str() function is similar to the summary function
# This shows us that there are 10 pages worth of elements in our rural_urban object

```


Let's check the first and last page:

```{r, eval=FALSE}
cat(rural_urban[1]) 
# Using the cat() function which stands for Concatenate And Print 
# This will allow for the "\n" values to be shown as spaces
```


```{r, echo = FALSE}
knitr::include_graphics(here::here("first_page_in_R.png"))
```


```{r, echo = FALSE}
knitr::include_graphics(here::here("first_page.png"))
```

This looks the same as the beginning... how about the end?

```{r, eval =FALSE}
cat(rural_urban[10])
```


```{r, echo = FALSE}
knitr::include_graphics(here::here("last_page_in_R.png"))
```


```{r, echo = FALSE }
knitr::include_graphics(here::here("last_page.png"))
```


Great! Our rural_urban object looks like it contains the entire Supplementary 3 table, as both the beginning and the end include the data we expected.

## Data Wrangling

At this point we have large strings now for each page of the table, but this is not very convenient to work with. Now we will wrangle the data into a more usable form. Ideally we would like our data to be in some sort of tabular form.

### Separate the data into lines

First it would be useful to separate each page into lines.
```{r}
rural_urban <-readr::read_lines(rural_urban)
str(rural_urban) 
# now we have 461 lines
rural_urban[6] 
# we can see that line 6 shows the data for females in Afghanistan  
```

### Removing excess white-space

We also have a lot of white-space... let's get rid of the excess white spaces using `str_squish()`.

```{r}
rural_urban<-stringr::str_squish(rural_urban) 
head(rural_urban)
```

Now it is much easier to see the data.

If we look at the end of the first page of the table and the start of the second we can see that the header information is repeated, as well as a line with the page number and an empty line, and a line that says "2 2".
```{r}
rural_urban[44:56]
```

Although the header was necessary on all of the pages of the pdf version of the table, we only need that information once in our data.

### Removing unnecessary repeated header information

So, let's remove all the header information and the page number lines from the rural_urban object, then we will make a single line header for the beginning.
One way to do this is to find all lines that include either "women" or "men" and only keep this data.
```{r}
stringr::str_which(string = rural_urban, pattern = "Women|Men") 
# Here the "|" indicates that we are looking for either the "Women" or "Men" patterns
```

OK, so this looks correct. This includes most lines but there are gaps where are header is located.

```{r}
rural_urban <- rural_urban[str_which(string = rural_urban, pattern = "Women|Men")]
```

We can check our data now using either head() or glimpse().
```{r}
dplyr::glimpse(rural_urban)
```

```{r}
head(rural_urban)
```

So the `head()` function shows us the first rows or lines of the data, while the `glimpse()` function provides us information about the total size of the object and shows us the first line or row.

Great! So now our data looks much better but we need to add back our header and we would like this to only be a single line to make it easy to transform our data into a table or table-like object.

```{r, echo = FALSE}
knitr::include_graphics(here::here("last_page.png"))
```

### Dealing with spacing

First let's try splitting our header-less data into columns based on spaces:
```{r}
(str_split(rural_urban, " ", simplify = TRUE))[1:10,] 
# Here we will take a look at just the first 10 lines
```

This almost worked, but unfortunately country names that have spaces will be a problem. We can see that American Samoa has been divided into two columns and all subsequent columns are shifted.


So now let's try to extract the country information, by separating the country information from the sex information when the sex is female. Sex always starts with either a capital "W" if the gender is female. We need to use a space before the "W" otherwise we will split some of the country names if the names starts with "W". Here we will also introduce the concept of piping, which uses the `%>%`. This is really useful when we have multiple steps, which we will show soon.
```{r}

Women <- stringr::str_subset(string = rural_urban, pattern = "Women") 
# First let's subset the data to only the lines that contain "Women"

country_split <-Women %>%
  stringr::str_split(pattern= " W") %>%
  unlist() 


head(country_split)
```

Now we can see that Country is always the odd rows and the rest of the data is the rest of the rows

```{r}
country <-data.frame(country_split) %>% 
  dplyr::filter(row_number() %% 2 == 1) 
```

We can take a look to make sure that all the country names look as expected:
```{r, eval= FALSE}
country
```

#### {.scrollable }
```{r, echo = FALSE}
country
```
####
```{r}
Women_BMI <-data.frame(country_split) %>% 
  dplyr::filter(row_number() %% 2 == 0)
```

Great! Now we have a list of the countries that can be used for both the male and female data. 

Let's add the "W" back to our Women data:
```{r}
glimpse(Women)
Women<-Women_BMI %>%
mutate(country_split =stringr::str_replace_all(string =country_split, pattern ="omen", replacement = "Women"))
head(Women$country_split)
```

It's always a good idea to check that your data objects are the size you expect when wrangling.

```{r}
dim(Women)
```
Great! There are 200 rows like we expected.

Let's grab the male data:

```{r}
# remember our rural_urban object contains male data for the odd rows

Men <-data.frame(rural_urban) %>% 
  dplyr::filter(row_number() %% 2 == 1) 
head(Men$rural_urban)

# Again let's make sure we have the correct number of rows for our final "Men" data object

dim(Men) 
```
How about our number of columns? 

If we try splitting our data by space again, will it have the expected number of columns? What about the rows that contain na* values?
```{r}
# Let's just take the Men data that contains na* values - this column is called rural_urban
unknown <-Men %>%filter(str_detect(pattern ="na\\*", string = rural_urban)) 

# Now we can try splitting by a space
tibble::as_tibble(str_split(unknown$rural_urban, " ", simplify = TRUE))

```

### Dealing with NA values

So close! Notice that the "na*" values  have shifted the subsequent values within the columns because typically there is a space between the BMI and the credible intervals. Here we can see this data in our original pdf:

```{r, echo = FALSE, out.width="100%"}
knitr::include_graphics(here::here("missing_pdf.png"))
```

We need to replace our na* values  with something that includes a space so that when we separate our data by space we will have two values instead of one when we have an na* . Therefore, na* na* should work.

```{r}
class(Men$rural_urban)
# In order to use the functions within the stringr package, our Men data needs to be of character class
Men<-as.character(Men$rural_urban) 
# This function allows us to change the factor data within Men$rural_urban to the character class
# We are changing the structure so that the data is directly just called Men and not within a vector called rural_urban
Men<-stringr::str_replace_all(string = Men, pattern = "na\\*", replacement = "na\\* na\\*") 
# The \\ are necessary because the * is a special character 
# The * would typically indicate any possible value, but here we actually want a "*" instead
# Thus the double backslash does that for us
# Here we are replacing all occurences of the na* values (thus str_replace_all instead of str_replace) with na* na*. 

# To check that this worked...
Men[20:30]
#YAY!


# Now for the Women data object
class(Women$country_split)
# the female data is already in character form
Women<-stringr::str_replace_all(string = Women$country_split, pattern = "na\\*", replacement = "na\\* na\\*") 
Women[20:30]

```


Great, now we can split our data by spaces.

### Splitting the data


```{r}
Men <-tibble::as_tibble(str_split(Men, " ", simplify = TRUE))
# Note here we need to use the column of Women that has the data
head(Men)
Women<-as_tibble(str_split(Women, " ", simplify = TRUE))
# Note here we need to use the column of Women that has the data
head(Women)
Women[20:30,] 
# We can see that our na values look correct
```

### Adding new header
We can see from our pdf and our object called header what the header was like. Let's also make a new single line header, but let's wait to add Country:

```{r}
#header
new_header <-c("Sex","National_BMI_1985", "National_BMI_1985_CI", "Rural_BMI_1985", "Rural_BMI_1985_CI", "Urban_BMI_1985", "Urban_BMI_1985_CI", "National_BMI_2017", "National_BMI_2017_CI","Rural_BMI_2017", "Rural_BMI_2017_CI", "Urban_BMI_2017", "Urban_BMI_2017_CI")
```


Let's change the names of our columns of our tibble to this new header for our Men and Women data

```{r}
names(Women)<-new_header
names(Men)<-new_header
```


Now we will add our country data to both our Men and Women tibbles:

```{r}
Women <- dplyr::bind_cols(country, Women)
# This will add the country as a new column to the Women data object on the left 
Men <- dplyr::bind_cols(country, Men) 
# This will add the country as a new column to the Men data object on the left 
head(Women)
```

### Changing variable names
Here we will change the variable name of the country data to country, currently it is called country_split. Here we will also introduce the concept of the assignment pipe. In this case our pipe operator looks like this `%<>%` .  Using this fancier pipe requires another package,  called `magrittr`. The other simpler pipe options from this package are loaded with `tidyverse` (if you used `library(tidyverse)` which loads most tidyverse packages), but not this fancier version. 

The `>` portion of the pipe still behaves like a normal pipe, while the `<` portion of the pipe makes an assignment to whatever the `<`is pointing to, just like when we use the typical assignment operator `<-`. 

```{r}
# library(magrittr) 
# We can't use the `%<>%` unless we load the magrittr package
# We have already done this but we include this for illustrative purposes.
# Here we will just use the traditional assignment strategy

Women<-rename(Women, Country = country_split) 
# We have renamed the country_split variable to be called Country

# Here we reassign Men using the pipe strategy
Men %<>%rename(Country = country_split) 
# We have renamed the country_split variable to to be called country
# We have also reassigned Men to the data object which has the country variable renamed
```


### Joining the data
Now we can combine our Men and Women data. This will put all the female data first (x) and all the male data second (y).


```{r}
BMI<-dplyr::full_join(x = Men, y = Women)
# Let's check the size of our BMI data... it should have 400 rows (obs).
str(BMI)
```

### Sorting the data
Now Lets sort the data by country:

```{r}
BMI <-dplyr::arrange(BMI, Country)
head(BMI)

```

Our data is looking great! Now we might want to make sure that our observations for each variable look the way we want. In other words if we want to make plots about National BMI in 1985 then we would need our values to be numeric. Looking at our BMI data using `str()`, we can see the type of data for each of our variables listed just after variable name and the ":" colon. Looks like none of our BMI data is actually numeric, but of the class character. Let's change that now.

```{r, warning=FALSE, eval}
str(BMI)
```
We could change these values to be numeric with 6 lines of code like this:
```{r, eval = TRUE}
BMI$National_BMI_1985%<>% as.numeric
BMI$Rural_BMI_1985%<>% as.numeric
BMI$Urban_BMI_1985%<>% as.numeric

BMI$National_BMI_2017%<>% as.numeric
BMI$Rural_BMI_2017%<>% as.numeric
BMI$Urban_BMI_2017%<>% as.numeric

#  And if we did this we would see these variables show as "num" which stands for numeric
str(BMI)
```

Or we can use a more automated way with the `purrr` package:
```{r}
BMI_numeric <- as_tibble(purrr::map((BMI %>% select(-matches("CI|Sex|Country"))), as.numeric)) 
# The map function of the purrr package allows us to apply the as.numeric() function to all the selected columns of BMI 
# We have selected those that dont contain CI, Sex, or Country in the column name 
# If you are familiar with apply(), this function is very similar
BMI_numeric %<>% mutate(Country =BMI$Country, Sex =BMI$Sex)
head(BMI_numeric)
```


It is generally useful to get the data in what is called <b>long</b> format for other analyses, and particularly for plotting. 

For a more detailed description about this, please see [this case study](https://opencasestudies.github.io/ocs-healthexpenditure/ocs-healthexpenditure.html)

To do this we will use the `gather()` function of the `tidyr` package:
```{r}
BMI_long <-tidyr::gather(data =BMI_numeric, key = class_BMI, value = BMI, National_BMI_1985:Urban_BMI_2017, factor_key = FALSE) 
# The data value indicates what data you start with
# The key indicates the new name of the column that will now contian information about  the values of the columns we will put together
# The value is the name of the column for the values for all the columns that are being put together
# The ":" can be used to indentify the start and end of the column names that you are putting together
# The factor_key paramater determines if the newly created key column should be evaluated as a factor or not
head(BMI_long)
```

It would be useful to parse the 1985 and the 2017 data. We can do so by separating the parts of the class_BMI column using the `separate()` function of the `tidyr` package.
```{r}
BMI_long%<>% tidyr::separate(class_BMI, c("Region", NA, "Year")) 
# We will separate the class_BMI column of the BMI_long tibble based on the underscores and create two new columns.
# The first column will be called Region and will contain the first part of the class_BMI data before the first underscore
# The second column will be called year and will contain the third part of the data based on the divisions of the underscore
# The middle part of the column will not be used to create any new columns
head(BMI_long)

# Let's see how the dimensions of the BMI data have changed now that it is in long format:

dim(BMI_numeric)
dim(BMI_long)

# Question opportunity: Why are there now 2,400 rows?
```


Great! our data is very usable now in this format!


## Data Exploration

Now that our data is clean and in a format that we can work with, we can start to take a look at the data and how different groups might compare.

Statistically speaking there are tests that can allow us to evaluate if the means of the groups are different. First let's see how our data looks in general.

### General summary


```{r}
summary(BMI_numeric)
# We can see that the mean  BMI estimates are larger in 2017
# Is this a meaningful increase?
```

Lets look at the Data separately by gender:
```{r}
#Women:
BMI_numeric %>% subset(Sex == "Women") %>% summary()

```

```{r}
#Men
BMI_numeric %>% subset(Sex == "Men") %>% summary()
```

It looks like mean BMIs have increased in all regions for both men and women. It is unclear though if this change is statistically significant.

### Distributions

In order to apply a statistical test to compare the means, one of the first things that is useful to do is to plot the frequency of the different possible values. This is called a <b>distribution</b>. To do this we can use the `hist()` function to create a histogram.

If the data were what we call <b>normally distributed</b> then the distribution should be equally centered around the mean and would look something like this:

```{r}
norm_BMI_ex_data <- tibble(norm_data =rnorm(n = 200, mean = 24))
# The rnorm() function allows us to make a vector of normaly distributed data centered around the mean of 24
head(norm_BMI_ex_data)
hist(norm_BMI_ex_data$norm_data)
```

Alternatively we can plot this using the `geom_hist()` function of the `ggplot2` package:

```{r}

norm_BMI_ex_data %>% ggplot2::ggplot(aes(x = norm_data)) + ggplot2::geom_histogram() 
# We are using the column called norm_data within the norm_BMI_ex_data data object
# With ggplot2 we must first specify the data we are using with the ggplot() function
# The geom_histogram() function specifies what type of plot to create
```

Let's see how our data looks:
```{r}
BMI_long%>% ggplot(aes(x = BMI)) + geom_histogram() 

```

OK, so the data looks like it is what we call <b>right skewed</b> because the tail of the distribution is longer on the right side, but it looks fairly normally distributed.

If we parse our data, what does it look like? The easiest way to do this is to use some other functions of the `ggplot2` package, particularly the `facet_wrap()` function, which will allow us to look at differences in the distribution of the BMI data by year, gender, and region. We can sequentially divide our plots by deeper levels using multiple variables and the `+` plus sign within `facet_wrap()`.
```{r, eval = TRUE}
BMI_long %>%
  ggplot(aes(x=BMI)) +
  geom_histogram()+
  facet_wrap( ~ Sex)

BMI_long %>%
  ggplot(aes(x=BMI)) +
  geom_histogram()+
  facet_wrap( ~ Sex + Year) 

BMI_long %>%
  ggplot(aes(x=BMI)) +
  geom_histogram() +
  facet_wrap( ~ Sex + Year + Region) 

```
### Quantile Quantile Plots

Let's use a method called quantile quantile plotting to determine if the data is indeed normally distributed. These plots are called <b>QQ plots</b>. This method allows us to test the fit of known theoretical distributions (like the normal distribution) with our observed distribution. To do this we will plot the quantiles of our data on the y-axis and the quantiles of the theoretical normal distribution on the x-axis. If the quantiles line up then we can say that our data is fairly normal. What exactly is a <b>quantile</b>? This is a division of the data distribution into roughly equal portions.

Here is an example of a QQ plot for the normally distributed data that we just created using the `stat_qq()` function of  the `ggplot2` package:

```{r}

norm_BMI_ex_data %>%
  ggplot(aes(sample =norm_data)) +
  stat_qq()+ # to add the line we need to also include stat_qq_line()
  stat_qq_line()



```

Here we can see that the quantiles are fairly similar between the observed and theoretical data. We see that the points mostly fall on the line, however there are some points that are a bit further from the line as we get to the extreme quantiles. Notice that the sample quantiles (which will be fairly similar to our real BMI data quantiles) on the y-axis has the same range as the values that we created. So values that are bellow 22 for example are represented as the points bellow 22 on the y-axis. As expected we see that about half the points are bellow our mean of 24.

If we were to use different data that had a range of different values our y-axis would shift according to the range of values. For example the Orange data within the installation of R includes data about the circumference of orange trees in millimeters. Here we can see that the quantiles are quite different but reflect the range of orange tree circumferences.
```{r}
range(Orange$circumference)
Orange%>%
  ggplot(aes(sample =circumference)) +
  stat_qq()+ # to add the line we need to also include stat_qq_line()
  stat_qq_line()
```


Let's take a look at our BMI data:

```{r}

BMI_long %>%
  ggplot(aes(sample =BMI)) +
  stat_qq()+ # to add the line we need to also include stat_qq_line()
  stat_qq_line()
```

For the sake of simplicity, we are going to focus on the data from the women.  This is because women were identified in the paper to have larger increases in BMI. If we want to perform tests on these groups specifically, then we need to know how this data looks.

```{r}

BMI_long %>%
  filter(Sex == "Women") %>%
  ggplot(aes(sample =BMI)) +
  stat_qq()+ # to add the line we need to also include stat_qq_line()
  stat_qq_line()
```


What about by region and year? If we compare these data then we need to look at the distribution of each of these subsets.

```{r}

BMI_long %>%
  filter(Sex == "Women", Year == "2017", Region == "Rural") %>%
  ggplot(aes(sample =BMI)) +
  stat_qq() + # to add the line we need to also include stat_qq_line()
  stat_qq_line() +
  ggtitle("QQ Plot for Women 2017 Rural Data")

BMI_long %>%
  filter(Sex == "Women", Year == "2017", Region == "Urban") %>%
  ggplot(aes(sample =BMI)) +
  stat_qq() + # to add the line we need to also include stat_qq_line()
  stat_qq_line() +
  ggtitle("QQ Plot for Women 2017 Urban Data")


BMI_long %>%
  filter(Sex == "Women", Year == "1985", Region == "Rural") %>%
  ggplot(aes(sample =BMI)) +
  stat_qq() + # to add the line we need to also include stat_qq_line()
  stat_qq_line() +
  ggtitle("QQ Plot for Women 1985 Rural Data")

BMI_long %>%
  filter(Sex == "Women", Year == "1985", Region == "Urban") %>%
  ggplot(aes(sample =BMI)) +
  stat_qq() + # to add the line we need to also include stat_qq_line()
  stat_qq_line() +
  ggtitle("QQ Plot for Women 1985 Urban Data")


```

We can see that at the extremes of our quantiles, for most of our data, our tails are not very similar to the theoretical distribution. The Rural data looks more normal than the urban data, but if we were to use statistical tests that rely on normality, this would require that both groups are normally distributed.

Finally, some statisticians also use the Shapiro-Wilk test for normality when the QQ plot is a bit unclear. Many statisticians however would conclude from the QQ plots that normality has been violated.

### Shapiro-Wilk test

For illustrative purposes we will show how we can use the dplyr summarize() and group_by() functions to perform the Shapiro-Wilk test for all the subsets we are interested in.

```{r}

norm_BMI_ex_data$norm_data %>% shapiro.test() 
# example of the test output for normal data

BMI_long %>% 
  filter(Sex == "Women") %>% 
  group_by(Year, Region) %>% 
  summarize(shapiro_test = shapiro.test(BMI)$p.value)

```

We see that all the data does not appear to be normally distributed.

## Data Analysis


We are interested in comparing the means of female rural and urban BMI measurements for both years. There are two possible classes of statistical tests that we could run to compare the means of these two groups:

1) Parametric
2) nonparametric

### Parametric two sample mean tests

Often when comparing two groups we might perform a two sample t test to determine if the means of each group is different. The two sample t test however, relies on several assumptions:

1) The data for both groups is normally distributed
2) The variance of both groups is similar

If these assumptions are violated, this doesn't necessarily mean we can't perform a t test. It just means we may have to transform the data to make it normally distributed and we may need to perform the t test in a special way to account for the difference in the variance in the two groups. Alternatively, we can use a nonparametric test like the Wilcoxon–Mann–Whitney (WMW) test. We will explore both of these options.

The t test is also fairly robust to non-normality if the data is relatively large, and we have an n of 200, which should be sufficient but let's investigate the nonparametric tests further. 


Often we would check if the variance of the rural and urban data is equal using the `var.test()` function. However this is an F test and assumes that the data is normally distributed. Instead we will use the `mood.test()` function.

```{r}


mood.test(pull(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Rural"), BMI), 
          pull(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Urban"), BMI))
# not equal - p value <.05 reject the null: no difference in the variance of the distributions

mood.test(pull(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Rural"), BMI), 
          pull(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Urban"), BMI))
# not equal - p value <.05, reject the null: no difference in the variance of the distributions

mood.test(pull(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Rural"), BMI), 
          pull(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Rural"), BMI))
# equal - p value >.05, accept the null: no difference in the variance of the distributions

mood.test(pull(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Urban"), BMI), 
          pull(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Urban"), BMI))
# equal - p value >.05, accept the null: no difference in the variance of the distributions

```

Our p value is less than .05 for both tests, thus we reject our null hypothesis that there is no difference in the variance. Therefore, we conclude that the variance is not equal and that our data also violates this assumption.

We will perform a special t.test where we account for the fact that our variance is not equal. 

Another important consideration is that the data is what we call <b>paired</b>. Meaning the measurements from the rural and urban areas are not independent. That is because we have a rural and urban measurement mean for nearly every country. Thus these values may be more similar to one another if they come from the same country.

```{r}

t.test(pull(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Rural"), BMI), 
       pull(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Urban"), BMI), 
       var.equal = FALSE, paired = TRUE)
# means are different - p value <.05 reject the null: no difference in the means

t.test(pull(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Rural"), BMI), 
       pull(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Urban"), BMI),
       var.equal = FALSE, paired = TRUE)
# means are different - p value <.05 reject the null: no difference in the means

t.test(pull(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Rural"), BMI), 
       pull(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Rural"), BMI),
       var.equal = FALSE, paired = TRUE)
# means are different - p value <.05 reject the null: no difference in the means

t.test(pull(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Urban"), BMI), 
       pull(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Urban"), BMI),
       var.equal = FALSE, paired = TRUE)
# means are different - p value <.05 reject the null: no difference in the means

```


Now we will try transform our data to make it more normally distributed. One way to do this is to take the logarithm of the data values. Then we will see how this influences the results.

```{r}

# create a new column with the log version of the BMI variable
BMI_long_log <- mutate(BMI_long, log_BMI=log(pull(BMI_long,BMI))) 


BMI_long_log %>%
  filter(Sex == "Women", Year == "2017", Region == "Rural") %>%
  ggplot(aes(sample =log_BMI)) +
  stat_qq() + # to add the line we need to also include stat_qq_line()
  stat_qq_line() +
  ggtitle("QQ Plot for Log Women 2017 Rural Data")

BMI_long_log %>%
  filter(Sex == "Women", Year == "2017", Region == "Urban") %>%
  ggplot(aes(sample =log_BMI)) +
  stat_qq() + # to add the line we need to also include stat_qq_line()
  stat_qq_line() +
  ggtitle("QQ Plot for Log Women 2017 Urban Data")


BMI_long_log %>%
  filter(Sex == "Women", Year == "1985", Region == "Rural") %>%
  ggplot(aes(sample =log_BMI)) +
  stat_qq() + # to add the line we need to also include stat_qq_line()
  stat_qq_line() +
  ggtitle("QQ Plot for Log Women 1985 Rural Data")

BMI_long_log %>%
  filter(Sex == "Women", Year == "1985", Region == "Urban") %>%
  ggplot(aes(sample =log_BMI)) +
  stat_qq() + # to add the line we need to also include stat_qq_line()
  stat_qq_line() +
  ggtitle("QQ Plot for Log Women 1985 Urban Data")


BMI_long_log %>% 
  filter(Sex == "Women") %>% 
  group_by(Year, Region) %>% 
  summarize(shapiro_test = shapiro.test(log_BMI)$p.value)

# recall what it was before
BMI_long %>% 
  filter(Sex == "Women") %>% 
  group_by(Year, Region) %>% 
  summarize(shapiro_test = shapiro.test(BMI)$p.value)

# so the data is more normal... but still not really normally distributed

```

Let's see the results of the t test with the transformed data:
```{r}

t.test(pull(filter(BMI_long_log, Sex == "Women", Year == "2017", Region == "Rural"), log_BMI), 
       pull(filter(BMI_long_log, Sex == "Women", Year == "2017", Region == "Urban"), log_BMI), 
       var.equal = FALSE, paired = TRUE)
# means are different - p value <.05 reject the null: no difference in the means

t.test(pull(filter(BMI_long_log, Sex == "Women", Year == "1985", Region == "Rural"), log_BMI), 
       pull(filter(BMI_long_log, Sex == "Women", Year == "1985", Region == "Urban"), log_BMI),
       var.equal = FALSE, paired = TRUE)
# means are different - p value <.05 reject the null: no difference in the means

t.test(pull(filter(BMI_long_log, Sex == "Women", Year == "1985", Region == "Rural"), log_BMI), 
       pull(filter(BMI_long_log, Sex == "Women", Year == "2017", Region == "Rural"), log_BMI),
       var.equal = FALSE, paired = TRUE)
# means are different - p value <.05 reject the null: no difference in the means

t.test(pull(filter(BMI_long_log, Sex == "Women", Year == "1985", Region == "Urban"), log_BMI), 
       pull(filter(BMI_long_log, Sex == "Women", Year == "2017", Region == "Urban"), log_BMI),
       var.equal = FALSE, paired = TRUE)
# means are different - p value <.05 reject the null: no difference in the means

```

The data appears to be more similar to the normal distribution, but most subsets still fail the Shapiro-Wilk normality test. Again, our sample size of 200 is quite large and the t test is generally quite robust to violations of normality with large n, thus the modified t test to account for unequal variance might be a good option using the log normalized data, as it is at least more normally distributed. However, let's take a look at non parametric tests, which are also a great option when the assumptions of the t test are violated. 

### Nonparametric two sample mean tests

There are two options to consider when the assumptions of the t test are violated. The Wilcoxon signed rank test and the Two-sample Kolmogorov-Smirnov test both do not assume normality. Thus these tests should be considered when the data of either groups does not appear to be normally distributed and particularly when the number of samples is low.

Importantly the Kolmogorov-Smirnov test does not assume normality or equal variance, while the Wilcoxon signed rank test does assume equal variance. Here is how you would perform these tests. However in our case, because the variance is not equal between our groups of interest, the Kolmogorov-Smirnov test would be more appropriate.

```{r}

#wilcox.test(pull(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Rural"), BMI), 
#            pull(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Urban"), BMI),
#            paired = TRUE)
#wilcox.test(pull(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Rural"), BMI), 
#            pull(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Urban"), BMI),
#            paired = TRUE))

ks.test(pull(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Rural"), BMI), 
        pull(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Urban"), BMI),
        paired = TRUE)

ks.test(pull(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Rural"), BMI), 
        pull(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Urban"), BMI),
        paired = TRUE)

```


##What about the difference in female BMI from 1985 to 2017 for both regions?

```{r}
ks.test(pull(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Rural"), BMI), 
        pull(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Rural"), BMI),
        paired = TRUE)

ks.test(pull(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Urban"), BMI), 
        pull(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Urban"), BMI),
        paired = TRUE)

```

## Data Visualization

```{r}
BMI_long %>% 
  filter(Sex == "Women", Year == "1985", Region != "National") %>%
  ggplot(aes(x = Region, y = BMI)) +
  geom_boxplot() +
  geom_jitter(width = .3)

BMI_long %>% 
  filter(Sex == "Women", Year == "2017", Region != "National") %>%
  ggplot(aes(x = Region, y = BMI)) +
  geom_boxplot() +
  geom_jitter(width = .3)

```

```{r}
BMI_long %>% 
  filter(Sex == "Women", Year %in% c("1985", "2017"), Region == "Rural") %>%
  ggplot(aes(x = Year, y = BMI)) +
  geom_boxplot() +
  geom_jitter(width = .3)

BMI_long %>% 
  filter(Sex == "Women", Year %in% c("1985", "2017"), Region == "Urban") %>%
  ggplot(aes(x = Year, y = BMI)) +
  geom_boxplot() +
  geom_jitter(width = .3)

```

How do the different countries compare?  Or in other words what do the individual dots represent in our box plots?
```{r}

BMI_long %>% 
  filter(Sex == "Women", Year %in% c("1985", "2017"), Region == "Rural") %>%
  ggplot(aes(x = Year, y = BMI)) +
  geom_boxplot() +
  geom_jitter(width = .3)+
  geom_label(aes(label = Country))

```
If we include all country names this is a bit too much... so perhaps we should focus on just the extreme BMI values. We will also use the `ggrepel` package to have our labels not overlap each other.




```{r}

BMI_long %>% 
  filter(Sex == "Women", Year %in% c("1985", "2017"), Region == "Rural") %>%
  ggplot(aes(x = Year, y = BMI)) +
  geom_boxplot() +
  geom_jitter(data=BMI_long %>% 
              filter(Sex == "Women", Year %in% c("1985", "2017"), Region == "Rural") %>%
              subset(BMI>31 | BMI<19 | Country == "United States of America"), 
              aes(x =Year, y =BMI),
              width = .02) +
  ggrepel::geom_text_repel(data=BMI_long %>% 
              filter(Sex == "Women", Year %in% c("1985", "2017"), Region == "Rural") %>%
              subset(BMI>31 | BMI<19 | Country == "United States of America"), 
              aes(x =Year, y =BMI, label = Country))
              
              
```

And let's fill the box plots with color and outline in black:
```{r}

BMI_long %>% 
  filter(Sex == "Women", Year %in% c("1985", "2017"), Region == "Rural") %>%
  ggplot(aes(x = Year, y = BMI)) +
  geom_boxplot(outlier.shape = NA, color = "black", aes(fill = Year)) +
  geom_jitter(data=BMI_long %>% 
              filter(Sex == "Women", Year %in% c("1985", "2017"), Region == "Rural") %>%
              subset(BMI>31 | BMI<19 | Country == "United States of America"), 
              aes(x =Year, y =BMI),
              width = .02) +
  ggrepel::geom_text_repel(data=BMI_long %>% 
              filter(Sex == "Women", Year %in% c("1985", "2017"), Region == "Rural") %>%
              subset(BMI>31 | BMI<19 | Country == "United States of America"), 
              aes(x =Year, y =BMI, label = Country))

```


### Overall differences

Let's take a look at all the data together:
```{r}
ggplot(BMI_long, aes(x = Year, y = BMI, col = Region)) + geom_boxplot(outlier.shape = NA, color = "black" , aes(fill = Region)) + facet_grid(~Sex)   
```

That's useful, but let's look at the individual points and include our country labels, to do so lets change our United States of America label to USA:
```{r}
BMI_long$Country <-BMI_long$Country %>%str_replace( pattern = "United States of America", replacement = "USA")


ggplot(BMI_long, aes(x = Year, y = BMI, col = Year)) + 
  geom_boxplot(outlier.shape = NA, color = "black" , aes(fill = Year)) + 
  facet_grid(~Sex + Region) + 
  geom_hline(yintercept=30, linetype="dashed", color = "red", size =1)  + 
  # This will add a horizontal dashed line to indicate BMI values considered to be in the range of obesity
  geom_jitter(data=subset(BMI_long), aes(x =Year, y =BMI), width = .2, size =2, shape =21, color = "black", fill = "gray")  + 
  # This will add the individual country data points
  # The shape 21 allows for a different fill and outline color ( the outline is the "color")
  # The width determines how wide the jitter points are plotted
  geom_jitter(data=subset(BMI_long, Country == "USA"), aes(x =Year, y =BMI), width = .02, size =12, shape =21, color = "black", fill = "gray") + 
  # This will add points that are larger for the USA data
  geom_text(data=subset(BMI_long,  Country == "USA"), aes(x =Year, y =BMI,label=Country), color = "black") + 
  # This will add USA labels to the USA points
  theme(legend.position = "none", 
  # This is useful for removing the legend
        axis.text.x = element_text(size = 15,angle = 30), 
        # this changes the size and angle of the x axis point labels 
        axis.text.y = element_text(size = 20), 
        axis.title.y = element_text(size =15), 
        axis.title.x = element_text(size =15), 
        strip.text.x = element_text(size = 15)) +
  # This changes the size of x axis labels for the facet 
        ggtitle( "Differences in BMI Over Time and Across Region Type and Gender") # Add a  plot title
   


```

Here we can see that overall BMI appears to be increasing globally over time. Additionally we can see that this is occurring not just in urban areas, but also in rural areas. The US is consistently above the median in all strata of the data. In general, the female data shows higher BMI values than the male data. The rural USA BMI appears to be higher than the urban BMI for both men and women. Many countries have average BMI estimates above the obesity threshold of 30. Thus it appears that education and outreach programs for weight management should focus on both rural and urban areas and both genders. Education and assistance for women may be especially helpful. 

### Differences in rate of increase

How does the rate of increase in BMI differ between groups? Which group might especially need attention?

First let's calculate the differences in BMI from 2017 and 1985 and add this to our BMI_long data object:
```{r}

BMI_numeric$Rural_difference <- BMI_numeric$Rural_BMI_2017 - BMI_numeric$Rural_BMI_1985
BMI_numeric$Urban_difference <- BMI_numeric$Urban_BMI_2017 - BMI_numeric$Urban_BMI_1985
BMI_numeric$National_difference <- BMI_numeric$National_BMI_2017 - BMI_numeric$National_BMI_1985

BMI_diff_long <- BMI_numeric %>% select(Country: National_difference) %>% gather(key = Type, value = Difference , Rural_difference:National_difference)
head(BMI_diff_long)
```

Let's replace "United states of America" with "USA" and make a plot with this data to compare the change in BMI:

```{r}

BMI_diff_long$Country <-BMI_diff_long$Country %>%str_replace( pattern = "United States of America", replacement = "USA")


ggplot(BMI_diff_long, aes(x = Type, y = Difference, col = Type)) + 
  geom_boxplot(outlier.shape = NA, color = "black" , aes(fill = Type)) + 
  facet_grid(~Sex) +
  geom_jitter(data=subset(BMI_diff_long), aes(x =Type, y =Difference), width = .2, size =2, shape =21, color = "black", fill = "gray")  + 
  # This will add the individual country data points
  # The shape 21 allows for a different fill and outline color ( the outline is the "color")
  # The width determines how wide the jitter points are plotted
  geom_jitter(data=subset(BMI_diff_long, Country == "USA"), aes(x =Type, y =Difference), width = .02, size =12, shape =21, color = "black", fill = "gray") + 
  # This will add points that are larger for the USA data
  geom_text(data=subset(BMI_diff_long,  Country == "USA"), aes(x =Type, y =Difference,label=Country), color = "black") + 
  # This will add USA labels to the USA points
  theme(legend.position = "none", 
  # This is useful for removing the legend
        axis.text.x = element_text(size = 15,angle = 30), 
        # this changes the size and angle of the x axis point labels 
        axis.text.y = element_text(size = 20), 
        axis.title.y = element_text(size =15), 
        axis.title.x = element_text(size =15), 
        strip.text.x = element_text(size = 15)) +
        # this changes the size of x axis labels for the facet
        ggtitle( "Change in BMI Over Time and Across Region Type and Gender" )# Add a plot title  



```

We can now see that the rate of change appears to be larger in the women compared to the men. The group with the largest increase in the USA is the women living in rural areas.
Thus this group should be especially focused on to improve this public health issue.

Now let's make a plot that summarizes the last two plots. To do this we will simplify the other two plots and then combine them together.

```{r}

# simplified national means plot
Means_plot<-BMI_long %>% 
  filter(Sex %in% c("Men", "Women"), Year %in% c("1985", "2017"), Region == "National") %>%
ggplot(aes(x = Sex, y = BMI)) + 
  geom_boxplot(outlier.shape = NA, color = "black" , aes(fill = Sex)) + 
 scale_fill_manual(values=c("dodgerblue", "orchid2"))+
  facet_grid(~Year) + 
  geom_hline(yintercept=30, linetype="dashed", color = "red", size =1)  + 
  geom_jitter(data=BMI_long 
                          %>%filter(Sex %in% c("Men", "Women"), Year %in% c("1985", "2017"), Region == "National"),
                          aes(x =Sex, y =BMI), width = .2, size =2, shape =21, color = "black", fill = "gray") +
  geom_jitter(data=subset(BMI_long 
                          %>%filter(Sex %in% c("Men", "Women"), Year %in% c("1985", "2017"), Region == "National"), 
                          Country == "USA"), aes(x =Sex, y =BMI), width = .02, size =12, shape =21, color = "black", fill = "gray") + 
  # This will add points that are larger for the USA data
  geom_text(data=subset(BMI_long
                        %>%filter(Sex %in% c("Men", "Women"), Year %in% c("1985", "2017"), Region == "National"),
                        Country == "USA"), aes(x =Sex, y =BMI,label=Country), color = "black") + 
  # This will add USA labels to the USA points
  theme(legend.position = "none", 
  # This is useful for removing the legend
        axis.text.x = element_text(size = 15,angle = 30), 
        # this changes the size and angle of the x axis point labels 
        axis.text.y = element_text(size = 20), 
        axis.title.y = element_text(size =15), 
        axis.title.x = element_text(size =15), 
        strip.text.x = element_text(size = 15))
   
#Simplified difference plot 
BMI_diff_long$Type <-BMI_diff_long$Type %>%str_replace( pattern = "_difference", replacement = "")

Diff_plot<-BMI_diff_long %>% 
  filter(Sex %in% c("Men", "Women"), Type != "National") %>%
ggplot( aes(x = Type, y = Difference, col = Type)) + 
  geom_boxplot(outlier.shape = NA, color = "black" , aes(fill = Sex)) + 
  scale_fill_manual(values=c("dodgerblue", "orchid2"))+
  facet_grid(~Sex) +
  geom_jitter(data=BMI_diff_long %>% 
    filter(Sex %in% c("Men", "Women"), Type != "National") , 
    aes(x =Type, y =Difference), width = .2, size =2, shape =21, color = "black", fill = "gray")  + 
  geom_jitter(data=subset(BMI_diff_long %>% 
    filter(Sex %in% c("Men", "Women"), Type != "National") , Country == "USA"), 
    aes(x =Type, y =Difference), width = .02, size =12, shape =21, color = "black", fill = "gray") + 
  # This will add points that are larger for the USA data
  geom_text(data=subset(BMI_diff_long %>% 
    filter(Sex %in% c("Men", "Women"), Type != "National") , Country == "USA"),
    aes(x =Type, y =Difference,label=Country), color = "black") + 
  # This will add USA labels to the USA points
  theme(legend.position = "none", 
  # This is useful for removing the legend
        axis.text.x = element_text(size = 15,angle = 30), 
        # this changes the size and angle of the x axis point labels 
        axis.text.y = element_text(size = 20), 
        axis.title.y = element_text(size =15), 
        axis.title.x = element_text(size =15), 
        strip.text.x = element_text(size = 15)) # this changes the size of x axis labels for the facet

Diff_plot<-Diff_plot + labs(title = "Change in BMI by region", x = "", y = "Increase in BMI \n (1985 to 2017)")+
    theme(title = element_text (size = 12, face = "bold"))
Means_plot <-Means_plot + labs(title = "Mean BMI over time", x = "", y = "Mean BMI")+
    theme(title = element_text (size = 12, face = "bold"))

cowplot::plot_grid(Means_plot, Diff_plot, labels = c("A", "B"))

```

## Summary

We have evaluated BMI average estimates from 200 different countries around the world. To do so we imported data from a pdf using the `pdftools` package. We used `tidyverse` packages such as `dplyr`, `stringr`, and `tidy` to clean the data and get it in a workable format. Our statistical analysis focused on evaluating differences in BMI in females around the world across time and between rural and urban areas. We found a significant difference both between years and between the type of community using t tests and nonparametric tests. Thus BMI has increased in women since 1985. Although BMI estimates are significantly higher in Urban areas compared to rural areas, BMI estimates have increased in both regions.  Using the `ggplot2` package we were able to visualize trends in the data. Importantly, the largest increase appears to be in the rural areas particularly for women. Analyses like this are important for defining which groups could benefit the most from interventions, education, and policy changes when attempting to mitigate public health challenges.

### Suggested Homework

Students can evaluate the change in BMI over time using the global data available for each year between 2015 and 2017. This data can be found [here](http://www.ncdrisc.org/downloads/bmi/NCD_RisC_Lancet_2017_BMI_age_standardised_world.csv).
