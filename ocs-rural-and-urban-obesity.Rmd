---
title: "Open Case Studies - Rural and Urban Obesity"
css: style.css
output:
  html_document:
    code_download: yes
    highlight: tango
    number_sections: no
    theme: cosmo
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
  word_document:
    toc: yes
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(include = TRUE, comment = NA, echo = TRUE,
                      message = FALSE, warning = FALSE)
```

```{r, echo = FALSE}
knitr::include_graphics(here::here("mainplot.png"))
```

## Motivation
BMI is measured as an individual's weight in kilograms divided by the individual's height in meters squared. Different categories of weight are defined with the following cutoffs:

![](https://cdn.vertex42.com/ExcelTemplates/Images/bmi-chart.gif)

An [article](https://www.nature.com/articles/s41586-019-1171-x.pdf) published in Nature evaluated and compared the Body-Mass Index (BMI) of populations in rural and urban communities around the world: 

```{r, echo = FALSE, out.width="100%", message=FALSE}
library(here)
knitr::include_graphics(here::here("paper.png"))

```

#### {.particular_topic_block}
NCD Risk Factor Collaboration (NCD-RisC). Rising rural body-mass index is the main driver of the global obesity epidemic in adults. *Nature* 569, 260–264 (2019). 

####
This article challenged the widely-held view that increased urbanization was one of the major reasons for increased global obesity rates. This view came about because many countries around the world have shown increased urbanization levels in parallel with increased obesity rates. However this study demonstrated that this might not be the case. This case study will evaluate the data reported in this article to explore regional and gender specific differences in the obesity rates around the world in 1985 and 2017. Most importantly we will test if there is a difference in obesity rates between rural and urban communities. 

<b><u> Our main questions are: </u></b>

1) Is there a difference between rural and urban BMI estimates around the world?
2) How have BMI estimates changed from 1985 to 2017?
3) How do different countries compare for BMI estimates- in particular, how does the United States compare to the rest of the world?

In this case study, we’ll walk you through importing data from a pdf, cleaning data, wrangling data, visualizing the data, and comparing the means of two groups using well-established and commonly used packages, including stringr, tidyr, dplyr, purrr, and ggplot2. We will especially focus on using packages and functions from the [Tidyverse](https://www.tidyverse.org/). The Tidyverse is a library of packages created by the chief scientist at RStudio, Hadley Wickham. While some students may be familiar with previous R programming packages, these packages make data science in R especially efficient.



```{r, out.width = "20%", echo = FALSE, fig.align ="center"}
library(knitr)
include_graphics("https://tidyverse.tidyverse.org/logo.png")
```

### Context

The measurement of BMI has some [limitations](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4890841/pdf/nt-50-117.pdf) that are well recognized, as it does not account for the composition of body mass, the location of body fat, or the contribution of body frame size. However, [BMI has been a useful health indicator](https://journals.lww.com/acsm-healthfitness/Fulltext/2016/07000/THE_BENEFITS_OF_BODY_MASS_INDEX_AND_WAIST.8.aspx#pdf-link) for risk for many diseases particularly when combined with other risk factor information.

## What is the Data?

We will be using data located within a table of the [supplementary material](https://static-content.springer.com/esm/art%3A10.1038%2Fs41586-019-1171-x/MediaObjects/41586_2019_1171_MOESM1_ESM.pdf) for the NCD-RisC paper referenced above. This is a pdf that can be found freely available online.


```{r, echo = FALSE}
knitr::include_graphics(here::here("first_page.png"))
```

Here you can see that the data contains mean BMI values for both Men and Women in various countries at the national level, as well as the mean BMI values for the rural and urban areas of these countries for both 1985 and 2017.

The data within the parantheses are the 95 % `credible interval` (CIs) ranges for the mean BMI estimates. The authors privide these CIs as a guide to understand how likely the estimate is for the true population mean BMI. A wider range suggests that the estimate is less accuate, as there are more possible values for the true mean with credible evidence.

<u>Note:</u> While sex is not actually binary, the data presented that is used in this analysis only contains data for groups of individuals described as male or female.

## Data Import

First let's download the data:
```{r}
library(here)
library(XML)

url <- "https://static-content.springer.com/esm/art%3A10.1038%2Fs41586-019-1171-x/MediaObjects/41586_2019_1171_MOESM1_ESM.pdf"

download.file(url, "paper_supplement.pdf")
```

Now that we have the obesity pdf, we will read it in to R using the  pdftools package:

```{r}
library(pdftools)

pdf_obesity<-pdf_text(here("paper_supplement.pdf"))# PDF error: Expected the optional content group list, but wasn't able to find it, or it isn't an Array - errors like this can be common with PDFs... we can take a look at the data to see if it still looks as expected
```

Let's take a look at the data- the summary() function helps us to look at the structure of R objects.

```{r}
summary(pdf_obesity)
```

We can see that we have 63 elements that are character strings. You may also notice that the original PDF has 63 pages. Let's take a look at some of these elements.

```{r}
pdf_obesity[1] # this looks like the first page
pdf_obesity[2] # this looks like the second page
```

```{r, eval = FALSE}
pdf_obesity[55] # this looks like data in a the table we are interested in
```

```{r, echo = FALSE, out.width="100%", message=FALSE}
library(here)
knitr::include_graphics(here::here("page55.png"))

```


We can see that the output looks pretty similar to the pages of the pdf, but the spacing is quite awkward. The way the data is displayed is partially influenced by how width setting of the RStudio window.  

We are interested in a supplementary Table 3. which has multiple pages and includes the same header on each page; we can use that to determine what elements of our pdf_obesity character strings include our table. We will use the str_detect() function of the stringr package to search for the elements that contain text that is consistently in the header. The output of of this function will show which elements of the object (in this case pages of the pdf) include this pattern indicated as a "TRUE" or "FALSE".

```{r}
library(stringr)
str_detect(pattern = "Age-standardised mean BMI", string = pdf_obesity)# "Age-standardised mean BMI" is part of the header in the table on every page in the pdf. This shows the pages that contain our table of interest (as TRUE values).
```

Let's extract just the data for the table now and call it rural_urban.
```{r}
rural_urban <-pdf_obesity[str_detect(pattern ="Age-standardised mean BMI", string =pdf_obesity)]

str(rural_urban) # the str() function (which is similar to the summary function) shows us that there are 10 pages worth of elements in our rural_urban object

```


Let's check the first and last page:

```{r, eval=FALSE}
cat(rural_urban[1]) # using the cat() function which stands for Concatenate And Print will allow for the "\n" values to be shown as spaces
```


```{r, echo = FALSE}
knitr::include_graphics(here::here("first_page_in_R.png"))
```


```{r, echo = FALSE}
knitr::include_graphics(here::here("first_page.png"))
```

This looks the same as the beginning... how about the end?

```{r, eval =FALSE}
cat(rural_urban[10])
```


```{r, echo = FALSE}
knitr::include_graphics(here::here("last_page_in_R.png"))
```


```{r, echo = FALSE }
knitr::include_graphics(here::here("last_page.png"))
```


Great! Our rural_urban object looks like it contains the entire Supplementary 3 table, as both the beginning and the end include the data we expected.

## Wrangling

At this point we have large strings now for each page of the table, but this is not very convenient to work with. Now we will wrangle the data into a more usable form. Ideally we would like our data to be in some sort of tabular form.

First it would be useful to separate each page into lines.
```{r}
library(readr)
rural_urban <-read_lines(rural_urban)
str(rural_urban) # now we have 461 lines
rural_urban[6] # we can see that line 6 shows the data for females in Afghanistan  
```

We also have a lot of white-space... let's get rid of the excess white spaces using `str_squish()`.

```{r}
library(tidyverse)
rural_urban<-str_squish(rural_urban) 
head(rural_urban)
```

Now it is much easier to see the data.

If we look at the end of the first page of the table and the start of the second we can see that the header information is repeated, as well as a line with the page number and an empty line, and a line that says "2 2".
```{r}
rural_urban[44:56]
```

Although the header was necessary on all of the pages of the pdf version of the table, we only need that information once in our data.


So, let's remove all the header information and the page number lines from the rural_urban object, then we will make a single line header for the beginning.
One way to do this is to find all lines that include either "women" or "men" and only keep this data.
```{r}
str_which(string = rural_urban, pattern = "Women|Men") # Here the "|" indicates that we are looking for either the "Women" or "Men" patterns
```

OK, so this looks correct. This includes most lines but there are gaps where are header is located.

```{r}
rural_urban <- rural_urban[str_which(string = rural_urban, pattern = "Women|Men")]
```

We can check our data now using either head() or glimpse().
```{r}
library(dplyr)
glimpse(rural_urban)
```

```{r}
head(rural_urban)
```

So the `head()` function shows us the first rows or lines of the data, while the `glimpse()` function provides us information about the total size of the object and shows us the first line or row.

Great! So now our data looks much better but we need to add back our header and we would like this to only be a single line to make it easy to transform our data into a table or table-like object.

```{r, echo = FALSE}
knitr::include_graphics(here::here("last_page.png"))
```


First let's try splitting our header-less data into columns based on spaces:
```{r}
(str_split(rural_urban, " ", simplify = TRUE))[1:10,] # here we will take a look at just the first 10 lines
```

This almost worked, but unfortunately country names that have spaces will be a problem. We can see that American Samoa has been divided into two columns and all subsequent columns are shifted.


So now let's try to extract the country information, by separating the country information from the sex information when the sex is female. Sex always starts with either a capital "W" if the gender is female. We need to use a space before the "W" otherwise we will split some of the country names if the names starts with "W". Here we will also introduce the concept of piping, which uses the `%>%`. This is really useful when we have multiple steps, which we will show soon.
```{r}

Women <- stringr::str_subset(string = rural_urban, pattern = "Women") # First let's subset the data to only the lines that contain "Women"

country_split <-Women %>%
  stringr::str_split(pattern= " W") %>%
  unlist() 


head(country_split)
```

Now we can see that Country is always the odd rows and the rest of the data is the rest of the rows

```{r}
country <-data.frame(country_split) %>% 
  dplyr::filter(row_number() %% 2 == 1) 
```

We can take a look to make sure that all the country names look as expected:
``` {r, eval= FALSE}
country
```

#### {.scrollable }
``` {r, echo = FALSE}
country
```
####
```{r}
Women_BMI <-data.frame(country_split) %>% 
  dplyr::filter(row_number() %% 2 == 0)
```

Great! Now we have a list of the countries that can be used for both the male and female data. 

Let's add the "W" back to our Women data:
```{r}
glimpse(Women)
Women<-Women_BMI %>%
mutate(country_split =stringr::str_replace_all(string =country_split, pattern ="omen", replacement = "Women"))
head(Women$country_split)
```

It's always a good idea to check that your data objects are the size you expect when wrangling.

```{r}
dim(Women)
```
Great! There are 200 rows like we expected.

Let's grab the male data:

```{r}
# remember our rural_urban object contains male data for the odd rows

Men <-data.frame(rural_urban) %>% 
  dplyr::filter(row_number() %% 2 == 1) 
head(Men$rural_urban)
dim(Men) # again let's make sure we have the correct number of rows for our final "Men" data object
```
How about our number of columns? 

If we try splitting our data by space again, will it have the expected number of columns? What about the rows that contain na* values?
```{r}
unknown <-Men %>%filter(str_detect(pattern ="na\\*", string = rural_urban)) # let's just take the Men data that contains na* values - this column is called rural_urban
as_tibble(str_split(unknown$rural_urban, " ", simplify = TRUE)) # now we can try splitting by a space

```

So close! Notice that the `na*` values  have shifted the subsequent values within the columns because typically there is a space between the BMI and the credible intervals. Here we can see this data in our original pdf:

```{r, echo = FALSE, out.width="100%"}
knitr::include_graphics(here::here("missing_pdf.png"))
```

We need to replace our `na*` values  with something that includes a space so that when we separate our data by space we will have two values instead of one when we have an `na*`. Therefore, `na* na*` should work.

```{r}
class(Men$rural_urban)# In order to use the functions within the stringr package, our Men data needs to be of character class
Men<-as.character(Men$rural_urban) # This function allows us to change the factor data within Men$rural_urban to the character class and we are changing the structure so that the data is directly just called Men and not within a vector called rural_urban
Men<-stringr::str_replace_all(string = Men, pattern = "na\\*", replacement = "na\\* na\\*") # the \\ are necessary because the * is a special character that would typically indicate that any possible value, but here we actually want a `*` instead, thus the double backslash does that for us.
# Here we are replacing all occurences of the na* values (thus str_replace_all instead of str_replace) that occur in the strings within Men with na* na*. 
#To check that this worked...
Men[20:30]
#YAY!


# Now for the Women data object
class(Women$country_split)# the female data is already in character form
Women<-stringr::str_replace_all(string = Women$country_split, pattern = "na\\*", replacement = "na\\* na\\*") 
Women[20:30]

```


Great, now we can split our data by spaces.



```{r}
Men <-as_tibble(str_split(Men, " ", simplify = TRUE))# note here we need to use the column of Women that has the data
head(Men)
Women<-as_tibble(str_split(Women, " ", simplify = TRUE))# note here we need to use the column of Women that has the data
head(Women)
Women[20:30,] # we can see that our na values look correct
```

We can see from our pdf and our object called header what the header was like. Let's also make a new single line header, but let's wait to add Country:

```{r}
#header
new_header <-c("Sex","National_BMI_1985", "National_BMI_1985_CI", "Rural_BMI_1985", "Rural_BMI_1985_CI", "Urban_BMI_1985", "Urban_BMI_1985_CI", "National_BMI_2017", "National_BMI_2017_CI","Rural_BMI_2017", "Rural_BMI_2017_CI", "Urban_BMI_2017", "Urban_BMI_2017_CI")
```


Let's change the names of our columns of our tibble to this new header for our Men and Women data

```{r}
names(Women)<-new_header
names(Men)<-new_header
```


Now we will add our country data to both our Men and Women tibbles:

```{r}
Women <- dplyr::bind_cols(country, Women)# this will add the country as a new column to the Women data object on the left 
Men <- dplyr::bind_cols(country, Men) # this will add the country as a new column to the Men data object on the left 
head(Women)
```

Here we will change the variable name of the country data to country, currently it is called country_split. Here we will also introduce the concept of the assignment pipe. In this case our pipe operator looks like this `%<>%` .  Using this fancier pipe requires another package,  called magrittr. The other simpler pipe options from this package are loaded with tidyverse, but not this fancier version. 

The `>` portion of the pipe still behaves like a normal pipe, while the `<` portion of the pipe makes an assignment to whatever the `<`is pointing to, just like when we use the typical assignment operator `<-`. 

```{r}
library(magrittr)
# Here we will just use the traditional assignment strategy
Women<-rename(Women, Country = country_split) # here we will rename the country_split variable to be called country

# Here we reassign Men using the pipe strategy
Men %<>%rename(Country = country_split) # here we will rename the country_split variable to to be called country and then reassign Men to the data object which has the country variable renamed
```

Now we can combine our Men and Women data. This will put all the female data first (x) and all the male data second (y).

```{r}
BMI<-dplyr::full_join(x = Men, y = Women)
str(BMI)#let's check the size of our BMI data... it should have 400 rows (obs).

```

Now Lets sort the data by country:

```{r}
BMI <-dplyr::arrange(BMI, Country)
head(BMI)

```

Our data is looking great! Now we might want to make sure that our observations for each variable look the way we want. In other words if we want to make plots about National BMI in 1985 then we would need our values to be numeric. Looking at our BMI data using `str()`, we can see the type of data for each of our variables listed just after variable name and the `:`. Looks like none of our BMI data is actually numeric, but of the class character. Let's change that now.

```{r, warning=FALSE, eval}
str(BMI)
```
We could change these values to be numeric with 6 lines of code like this:
```{r, eval = TRUE}
BMI$National_BMI_1985%<>% as.numeric
BMI$Rural_BMI_1985%<>% as.numeric
BMI$Urban_BMI_1985%<>% as.numeric

BMI$National_BMI_2017%<>% as.numeric
BMI$Rural_BMI_2017%<>% as.numeric
BMI$Urban_BMI_2017%<>% as.numeric

str(BMI)#  and if we did this we would see these variables show as "num" which stands for numeric
```

Or we can use a more automated way with the purrr package:
```{r}
library(purrr)
BMI_numeric <- as.tibble(map((BMI %>% select(-matches("CI|Sex|Country"))), as.numeric)) # the map function of the purrr package allows us to apply the as.numeric() function to all the selected columns of BMI (those that dont contain CI, Sex, or Country in the column name) if you are familiar with apply(), this function is very similar.
BMI_numeric %<>% mutate(Country =BMI$Country, Sex =BMI$Sex)
head(BMI_numeric)
```


It is generally useful to get the data in what is called `long` format for other analyses, and particularlly for plotting. 

For a more detailed description about this, please see [this case study](https://opencasestudies.github.io/ocs-healthexpenditure/ocs-healthexpenditure.html)

To do this we will use the `gather()` function:
```{r}
BMI_long <-gather(data =BMI_numeric, key = class_BMI, value = BMI, National_BMI_1985:Urban_BMI_2017, factor_key = FALSE) # the data value indicates what data you start with, the key indicates the new name of the column that will now have all information about what the values of the columns that you will put together are, the value is the name of the column for the values for all the columns that are being put together, the ":" can be used to indentify the start and end of the column names that you are putting together, and the factor_key paramater determines if the newly created key column should be evaluated as a factor or not.
head(BMI_long)
```

It would be usefull to parse the 1985 and the 2017 data. We can do so by separating the parts of the class_BMI column using the `separate()` function of the `tidyr package`.
```{r}
library(tidyr)
BMI_long%<>% separate(class_BMI, c("Region", NA, "Year")) # we will sepearte the class_BMI column of the BMI_long tibble based on the underscores and create two new columns. The first column will be called Region and will contain the first part of the class_BMI data before the first underscore and the second column will be called year and will contain the third part of the data based on the divisions of the underscore. The middle part of the column will not be used to create any new columns.
head(BMI_long)

```


Great! our data is very usable now in this format!


## Data Exploration

Now that our data is clean and in a format that we can work with, we can start to take a look at the data and how different groups might compare.

One of the first things that is useful to do with data is to plot the frequency of the different possible values. This is called a `distribution`. To do this we can use the `hist()` function to create a histogram.

If the data were what we call `normally distributed` then the distribution should be equally centered around the mean and would look something like this:

```{r}
norm_BMI_ex_data <- rnorm(n = 200, mean = 24) # this function allows us to make a vector of normaly distributed data centered around the mean of 24
hist(norm_BMI_ex_data)
```

Alternatively we can plot this using the `qplot()` function of the `ggplot2 package`:

```{r}
qplot(norm_BMI_ex_data)
qplot(norm_BMI_ex_data, bins = 15) # we can modify how we bin our histogram using the bin argument- in other words, how many bars would we like to include
```

Let's see how our data looks:
```{r}
qplot(BMI_long$BMI)
```

OK, so the data looks like it is what we call `right skewed` because the tail of the distribution is longer on the right side, but it looks fairly normally distributed.

If we parse our data, what does it look like? The easiest way to do this is to use some other functions of the ggplot2 package, particularly the facet_wrap() function, which will allow us to look at differences in the distribution of the BMI data by year, gender, and region.
```{r, eval = TRUE}
library(ggplot2)

ggplot(BMI_long, aes(x=BMI)) + geom_histogram() 
ggplot(BMI_long, aes(x=BMI)) + geom_histogram() + facet_wrap( ~ Sex)
ggplot(BMI_long, aes(x=BMI)) + geom_histogram() + facet_wrap( ~ Sex + Year) 
ggplot(BMI_long, aes(x=BMI)) + geom_histogram() + facet_wrap( ~ Sex + Year + Region) 

```
 
Let's use a method called quantile quantile plotting to determine if the data is indeed normally distributed. These plots are called `QQ plots`. This method allows us to test the fit of known theoretical distributions (like the normal distribution) with our observed distribution. To do this we will plot the quantiles of our data on the y-axis and the quantiles of the theoretical normal distribution on the x-axis. If the quantiles line up then we can say that our data is fairly normal. What exactly is a `quantile`? This is a division of the data distribution into roughly equal portions.

Here is an example of a QQ plot for the normally distributed data that we just created:

```{r}

qqnorm(norm_BMI_ex_data)
qqline(norm_BMI_ex_data)

```

Here we can see that the quantiles are fairly similar bewteen the observed and theoretical data. We see that the points mostly fall on the line, however there are some points that are a bit further from the line as we get to the extreme quantiles. Notice that the sample quantiles (which will be fairly similar to our real BMI data quantiles) on the y-axis has the same range as the values that we created. So values that are bellow 22 for example are represented as the points bellow 22 on the y-axis. As expected we see that about half the points are bellow our mean of 24.

If we were to use different data that had a range of differnt values our y-axis would shift according to the range of values. For example the Orange data within the installation of R includes data about the circumfrance of orange trees in millimeters. Here we can see that the quantiles are quite different but reflect the range of orange tree circumfrances.
```{r}
range(Orange$circumference)
qqnorm(Orange$circumference)
qqline(Orange$circumference)
```


Let's take a look at our BMI data:

```{r}

qqnorm(BMI_long$BMI)
qqline(BMI_long$BMI)
```

We are particularly insterested in data for Women for each year and region. How does this data look?
```{r}

qqnorm(filter(BMI_long, Sex == "Women")$BMI)
qqline(filter(BMI_long, Sex == "Women")$BMI)

qqnorm(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Rural")$BMI)
qqline(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Rural")$BMI)

qqnorm(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Urban")$BMI)
qqline(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Urban")$BMI)

qqnorm(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Rural")$BMI)
qqline(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Rural")$BMI)

qqnorm(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Urban")$BMI)
qqline(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Urban")$BMI)
```
We can see that at the extremes of our quantiles, for most of our data, our tails are not very similar to the theoretical distribution.

Finally, we can also use the Shapiro-Wilk test for normality when the qqplot is a bit unclear.

```{r}

shapiro.test(norm_BMI_ex_data) # example of the test output for normal data
shapiro.test(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Urban")$BMI)
shapiro.test(filter(BMI_long, Sex == "Women", Year == "2017", Region == "Rural")$BMI)
shapiro.test(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Urban")$BMI)
shapiro.test(filter(BMI_long, Sex == "Women", Year == "1985", Region == "Rural")$BMI)

```

## Data Analysis

We are interested in comparing the female rural and urban BMI measurements for both years, but the data does not appear to be normally distributed. Often when comparing two groups we might perform a two sample t test to determine if the means of each group is different. The two sample t test however, relies on several assumptions:

1) The data for both groups is normally distributed
2) The variance of both groups is similar

If these assumptions are violated, this doesn't necessarily mean we can't perform a t test. It just means we may have to transform the data to make it normally distributed and we may need to peform the t test in a special way to account for the difference in the variance in the two groups. Alternatively, we can use a nonparametric test like the Wilcoxon–Mann–Whitney (WMW) test. We will explore both of these options.

The t test is also fairly robust to non-normality if the data is relatively large, and we have an n of 200, which should be sufficent but let's investigate this further.

Let's check if the variance of the rural and urban data is equal using the `var.test()` function.

```{r}
library(data.table)
women_2017 <- data.table::data.table(Urban = filter(BMI_long, Sex == "Women", Year == "2017", Region == "Urban")$BMI, Rural = filter(BMI_long, Sex == "Women", Year == "2017", Region == "Rural")$BMI)

women_1985 <- data.table::data.table(Urban = filter(BMI_long, Sex == "Women", Year == "1985", Region == "Urban")$BMI, Rural = filter(BMI_long, Sex == "Women", Year == "1985", Region == "Rural")$BMI)

rownames(women_2017) <-country$country_split
rownames(women_1985) <-country$country_split

head(women_2017)
head(women_1985)

var.test(women_2017$Urban, women_2017$Rural)

var.test(women_1985$Urban, women_1985$Rural)

```

Our p value is just a bit less than .05 for both tests, thus we reject our null hypothesis that there is no difference in the variance. Therefore, we conclude that the variance is not equal and that our data also violates this assumption.

We will perform a special t.test where we account for the fact that our variance is not equal. 

Another important consideration is that the data is what we call `paired`. Meaning the measurements from the rural and urban areas are not independent. That is because we have a rural and urban measurement mean for nearly every country. Thus these values may be more similar to one another if they come from the same country.

```{r}
t.test(women_1985$Urban, women_1985$Rural, var.equal = FALSE, paired = TRUE)
t.test(women_2017$Urban, women_2017$Rural, var.equal = FALSE, paired = TRUE)

```


Now we will try transform our data to make it more normally distributed. One way to do this is to take the logarithm of the data values. 

```{r}

women_1985_log <- log(women_1985)
women_2017_log <- log(women_2017)
map(women_2017_log, shapiro.test)
map(women_1985_log, shapiro.test)

t.test(women_1985_log$Urban, women_1985_log$Rural, var.equal = FALSE, paired = TRUE)
t.test(women_2017_log$Urban, women_2017_log$Rural, var.equal = FALSE, paired = TRUE)

```

The data appears to be more similar to the normal distribution, but in some cases still fails the Shapiro-Wilk normality test. Again, our sample size of 200 is quite large and the t test is generally quite robost to violations of normality with large n, thus the modified t test to account for unequal variance might be a good option using the log normalized data, as it is at least more normally distributed. However, let's take a look at non parametric tests, which are also a great option when the assumptions of the t test are violated. 

### Nonparametric two sample mean tests

There are two options to consider when the assumptions of the t test are violated. The Wilcoxon signed rank test and the Two-sample Kolmogorov-Smirnov test both do not assume normality. Thus these tests should be considered when the data of either groups does not appear to be normally distributed and particularly when the number of samples is low.

Importantly the Kolmogorov-Smirnov test does not assume normality or equal variance, while the Wilcoxon signed rank test does assume equal variance. Here is how you would perform these tests. However in our case, even though the variance was quite similar between our groups of interest, the Kolmogorov-Smirnov test would be more appropriate.

```{r}

wilcox.test(women_2017$Urban, women_2017$Rural, paired = TRUE)
wilcox.test(women_1985$Urban, women_1985$Rural,paired = TRUE)

ks.test(women_2017$Urban, women_2017$Rural, paired = TRUE)
ks.test(women_1985$Urban, women_1985$Rural, paired = TRUE)
```


##What about the difference in female BMI from 1985 to 2017 for both regions?

```{r}
var.test(women_2017$Rural, women_1985$Rural) # the varaince is equal so the Wilcoxon signed rank test will work well.
wilcox.test(women_2017$Rural, women_1985$Rural, paired = TRUE)

var.test(women_2017$Urban, women_1985$Urban) # the varaince is equal so the Wilcoxon signed rank test will work well.
wilcox.test(women_2017$Urban, women_1985$Urban, paired = TRUE)

```

## Data Visualization

```{r}

ggplot(gather(women_1985), aes(x = key, y =value, col = key)) + geom_boxplot() +geom_jitter(width = .3)
ggplot(gather(women_2017), aes(x = key, y =value, col = key)) + geom_boxplot() +geom_jitter(width = .3)

```

```{r}
Rural_women <- tibble(BMI_2017 = women_2017$Rural, BMI_1985 = women_1985$Rural)
Urban_women <- tibble(BMI_2017 = women_2017$Urban, BMI_1985 = women_1985$Urban)

ggplot(gather(Rural_women), aes(x = key, y =value, col = key)) + geom_boxplot() +geom_jitter(width = .3)
ggplot(gather(Urban_women), aes(x = key, y =value, col = key)) + geom_boxplot() +geom_jitter(width = .3)


```

How do the different countries compare?  Or in otherwords what do the individual dots represent in our boxplots?
```{r}
library(ggplot2)

women_1985$country <- country$country_split # Let's add the country names
women_1985_long<-gather(women_1985, key = Type, value = BMI, Urban:Rural) # Let's put the type of BMI in long format again, but not inlcude the country in long format
head(women_1985_long)

women_2017$country <- country$country_split # Let's add the country names
women_2017_long<-gather(women_2017, key = Type, value = BMI, Urban:Rural) # Let's put the type of BMI in long format again, but not inlcude the country in long format
head(women_2017_long)

ggplot(women_1985_long, aes(x = Type, y =BMI, col = Type)) + geom_boxplot() + geom_label(aes(label = country))  
```
If we include all country names this is a bit too much... so perhaps we should focus on just the extreme BMI values:
```{r}
library(ggrepel)
ggplot(women_1985_long, aes(x = Type, y =BMI, col = Type)) + geom_boxplot(outlier.shape = NA)+geom_text(data=subset(women_1985_long, BMI>31 | BMI<19 | country == "United States of America"), aes(x =Type, y =BMI,label=country)) + geom_jitter(data=subset(women_1985_long, BMI>31 | BMI<19 | country == "United States of America"), aes(x =Type, y =BMI,label=country), width = .02) + geom_text_repel(data=subset(women_1985_long, BMI>31 | BMI<19 | country == "United States of America"), aes(x =Type, y =BMI,label=country))
```

And let's fill the boxplots with color and outline in black:
```{r}
ggplot(women_1985_long, aes(x = Type, y =BMI, col = Type)) + geom_boxplot(outlier.shape = NA, aes(fill = Type), color = "black") + geom_jitter(data=subset(women_1985_long, BMI>31 | BMI<19 | country == "United States of America"), aes(x =Type, y =BMI,label=country), width = .02) + geom_text_repel(data=subset(women_1985_long, BMI>31 | BMI<19 | country == "United States of America"), aes(x =Type, y =BMI,label=country))

ggplot(women_2017_long, aes(x = Type, y =BMI, col = Type)) + geom_boxplot(outlier.shape = NA, aes(fill = Type), color = "black") + geom_jitter(data=subset(women_2017_long, BMI>33 | BMI<20 | country == "United States of America"), aes(x =Type, y =BMI,label=country), width = .02) + geom_text_repel(data=subset(women_2017_long, BMI>31 | BMI<20 | country == "United States of America"), aes(x =Type, y =BMI,label=country))
```




Let's take a look at all the data together:
```{r}
ggplot(BMI_long, aes(x = Year, y = BMI, col = Region)) + geom_boxplot(outlier.shape = NA, color = "black" , aes(fill = Region)) + facet_grid(~Sex)   
```

That's useful, but let's look at the individual points and include our country labels, to do so lets change our United States of America label to USA:
```{r}
BMI_long$Country <-BMI_long$Country %>%str_replace( pattern = "United States of America", replacement = "USA")


ggplot(BMI_long, aes(x = Year, y = BMI, col = Year)) + 
  geom_boxplot(outlier.shape = NA, color = "black" , aes(fill = Year)) + 
  facet_grid(~Sex + Region) + 
  geom_hline(yintercept=30, linetype="dashed", color = "red", size =1)  + # this will add a horizontal dashed line to indicate BMI values considered to be in the range of obesity
  geom_jitter(data=subset(BMI_long), aes(x =Year, y =BMI), width = .2, size =2, shape =21, color = "black", fill = "gray")  + # this will add the individual country data points, the shape 21 allows for a different fill and outline color ( the outline is the "color"), the width determines how wide the jitter points are plotted
  geom_jitter(data=subset(BMI_long, Country == "USA"), aes(x =Year, y =BMI), width = .02, size =12, shape =21, color = "black", fill = "gray") + # this will add points that are larger for the USA data
  geom_text(data=subset(BMI_long,  Country == "USA"), aes(x =Year, y =BMI,label=Country), color = "black")+ # this will add USA labels to the USA points
  theme(legend.position = "none", # this is useful for removing the legend
        axis.text.x = element_text(size = 15,angle = 30), # this changes the size and angle of the x axis point labels 
        axis.text.y = element_text(size = 20), 
        axis.title.y = element_text(size =15), 
        axis.title.x = element_text(size =15), 
        strip.text.x = element_text(size = 15)) +
        ggtitle( "Differences in Body-Mass Index (BMI) Over Time and Across Region Type and Gender" ) # this changes the size of x axis labels for the facet 


```


How does the rate of increase in BMI differ between the groups?

```{r}
women_diff <-women_2017 -women_1985

women_diff$country <- country$country_split # Let's add the country names
women_diff_long<-gather(women_diff, key = Type, value = Difference, Urban:Rural) # Let's put the type of BMI in long format again, but not inlcude the country in long format
head(women_diff_long)

ggplot(women_diff_long, aes(x = Type, y =Difference, col = Type)) + geom_boxplot(outlier.shape = NA, aes(fill = Type), color = "black") + geom_jitter(data=subset(women_diff_long,  country == "United States of America"), aes(x =Type, y =Difference,label=country), width = .02) + geom_text_repel(data=subset(women_diff_long, country == "United States of America"), aes(x =Type, y =Difference,label=country))

BMI_numeric$Rural_difference <- BMI_numeric$Rural_BMI_2017 - BMI_numeric$Rural_BMI_1985
BMI_numeric$Urban_difference <- BMI_numeric$Urban_BMI_2017 - BMI_numeric$Urban_BMI_1985
BMI_numeric$National_difference <- BMI_numeric$National_BMI_2017 - BMI_numeric$National_BMI_1985

BMI_diff_long <- BMI_numeric %>% select(Country: National_difference) %>% gather(key = Type, value = Difference , Rural_difference:National_difference)
BMI_diff_long$Country <-BMI_diff_long$Country %>%str_replace( pattern = "United States of America", replacement = "USA")

ggplot(BMI_diff_long, aes(x = Type, y = Difference, col = Type)) + 
  geom_boxplot(outlier.shape = NA, color = "black" , aes(fill = Type)) + 
  facet_grid(~Sex) +
  geom_jitter(data=subset(BMI_diff_long), aes(x =Type, y =Difference), width = .2, size =2, shape =21, color = "black", fill = "gray")  + # this will add the individual country data points, the shape 21 allows for a different fill and outline color ( the outline is the "color"), the width determines how wide the jitter points are plotted
  geom_jitter(data=subset(BMI_diff_long, Country == "USA"), aes(x =Type, y =Difference), width = .02, size =12, shape =21, color = "black", fill = "gray") + # this will add points that are larger for the USA data
  geom_text(data=subset(BMI_diff_long,  Country == "USA"), aes(x =Type, y =Difference,label=Country), color = "black")+ # this will add USA labels to the USA points
  theme(legend.position = "none", # this is useful for removing the legend
        axis.text.x = element_text(size = 15,angle = 30), # this changes the size and angle of the x axis point labels 
        axis.text.y = element_text(size = 20), 
        axis.title.y = element_text(size =15), 
        axis.title.x = element_text(size =15), 
        strip.text.x = element_text(size = 15)) +
        ggtitle( "Change in Body-Mass Index (BMI) Over Time and Across Region Type and Gender" ) # this changes the size of x axis labels for the facet 



```



Here we can see that overall BMI appears to be increasing globally over time. Additionally we can see that this is occuring not just in urban areas, but also in rural areas. The US is consistently above the median in all strata of the data. In general, the female data shows higher BMI values than the male data. The rural USA BMI appears to be higher than the urban BMI for both men and women. Many countries have average BMI estimates above the obesity threshold of 30. Thus it appears that education and outreach programs for weight management should focus on both rural and urban areas and both genders. Education and assistance for women may be especially helpful. 



## Summary

We have evaluated BMI average estimates from 200 different countries around the world. Our statistical analysis focused on evaluating differences in BMI in females around the world across time and between rural and urban areas. We found a significant difference both between years and between the type of community using t tests and nonparametric tests. Thus BMI has increased in women since 1985. Although BMI estimates are significantly higher in Urban areas compared to rural areas, BMI estimates have increased in both regions.

### Suggested Homework

Students can evaluate the change in BMI overtime using the global data available for each year between 2015 and 2017. This data can be found [here](http://www.ncdrisc.org/downloads/bmi/NCD_RisC_Lancet_2017_BMI_age_standardised_world.csv).
